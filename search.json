{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Geodistpy Documentation","text":"<p>Welcome to the documentation for the <code>geodistpy</code> project — a high-performance Python package for geospatial distance calculations between geographical coordinates.</p>","path":["Geodistpy – Fast Geodesic Distance Calculations in Python"],"tags":[]},{"location":"#table-of-contents","level":2,"title":"Table Of Contents","text":"<ol> <li>Getting Started — Installation and quick start guide</li> <li>Bearing &amp; Destination — Forward azimuth and Vincenty direct/inverse</li> <li>Interpolation &amp; Midpoints — Geodesic waypoints and path generation</li> <li>Spatial Queries — k-NN and point-in-radius on the ellipsoid</li> <li>API Reference — Complete function reference</li> <li>Benchmarks &amp; Internals — Performance benchmarks and implementation details</li> </ol>","path":["Geodistpy – Fast Geodesic Distance Calculations in Python"],"tags":[]},{"location":"#introduction","level":2,"title":"Introduction","text":"<p>The <code>geodistpy</code> package is a versatile library for geospatial calculations, offering various distance metrics and functionalities. It is built on the principles of geodesy and uses the WGS 84 coordinate system, making it suitable for a wide range of applications, from GPS tracking to geographical analysis.</p>","path":["Geodistpy – Fast Geodesic Distance Calculations in Python"],"tags":[]},{"location":"#key-features","level":3,"title":"Key Features","text":"<ul> <li>Blazing fast: ~0.4 µs per distance call — up to 171x faster than Geopy, 109x faster than Geographiclib</li> <li>Parallel matrix computation: Up to 1,230x faster than Geopy for pairwise distance matrices using Numba parallel execution</li> <li>Sub-millimeter accuracy: Vincenty's inverse formula with mean error of just 9 µm vs Geographiclib reference</li> <li>Improved Great Circle: Andoyer-Lambert flattening correction reduces spherical approximation error by 700x (from ~13 km to ~19 m)</li> <li>Edge case handling: Antipodal points, poles, date line crossings, and very short distances all handled correctly</li> <li>Bearing &amp; destination: Compute forward azimuth between points and find destination given start + bearing + distance (Vincenty inverse/direct pair)</li> <li>Geodesic interpolation: Generate evenly-spaced waypoints and midpoints along geodesics for routing and visualization</li> <li>Spatial queries: Point-in-radius filtering (geofencing) and k-nearest-neighbour search using exact ellipsoidal distances</li> <li>Multiple ellipsoids: Built-in support for WGS-84, GRS-80, Airy 1830, Intl 1924, Clarke 1880, GRS-67, or pass any custom <code>(a, f)</code> tuple</li> </ul>","path":["Geodistpy – Fast Geodesic Distance Calculations in Python"],"tags":[]},{"location":"#quick-example","level":2,"title":"Quick Example","text":"<pre><code>from geodistpy import geodist, bearing, destination, midpoint, geodesic_knn\n\n# Define two coordinates (latitude, longitude)\nberlin = (52.5200, 13.4050)\nparis  = (48.8566, 2.3522)\n\n# Distance\ndistance_km = geodist(berlin, paris, metric='km')\nprint(f\"Distance: {distance_km:.1f} km\")\n\n# Bearing (forward azimuth)\nb = bearing(berlin, paris)\nprint(f\"Bearing: {b:.2f}°\")\n\n# Destination: travel 500 km due east from Berlin\nlat, lon = destination(berlin, 90.0, 500, metric='km')\nprint(f\"Destination: ({lat:.4f}, {lon:.4f})\")\n\n# Midpoint\nmid = midpoint(berlin, paris)\nprint(f\"Midpoint: ({mid[0]:.4f}, {mid[1]:.4f})\")\n\n# k-NN: find 2 nearest cities to Berlin\ncities = [(48.8566, 2.3522), (51.5074, -0.1278), (40.7128, -74.006)]\nidx, dists = geodesic_knn(berlin, cities, k=2, metric='km')\nprint(f\"2 nearest: {idx}, distances: {dists.round(1)} km\")\n</code></pre>","path":["Geodistpy – Fast Geodesic Distance Calculations in Python"],"tags":[]},{"location":"#using-different-ellipsoids","level":3,"title":"Using Different Ellipsoids","text":"<p>All functions accept an optional <code>ellipsoid</code> parameter. By default, WGS-84 is used:</p> <pre><code>from geodistpy import geodist, ELLIPSOIDS\n\n# Use a named ellipsoid (GRS-80, Airy 1830, Intl 1924, Clarke 1880, GRS-67)\nd = geodist(berlin, paris, metric='km', ellipsoid='GRS-80')\nprint(f\"GRS-80 distance: {d:.1f} km\")\n\n# Use a custom (semi_major_axis, flattening) tuple\nd = geodist(berlin, paris, ellipsoid=(6378137.0, 1/298.257223563))\nprint(f\"Custom ellipsoid distance: {d:.1f} m\")\n\n# List all available ellipsoids\nprint(ELLIPSOIDS.keys())\n</code></pre>","path":["Geodistpy – Fast Geodesic Distance Calculations in Python"],"tags":[]},{"location":"#links","level":2,"title":"Links","text":"<ul> <li>PyPI: pypi.org/project/geodistpy</li> <li>GitHub: github.com/pawangeek/geodistpy</li> </ul>","path":["Geodistpy – Fast Geodesic Distance Calculations in Python"],"tags":[]},{"location":"#license","level":2,"title":"License","text":"<p>The geodistpy project is licensed under the MIT License.</p>","path":["Geodistpy – Fast Geodesic Distance Calculations in Python"],"tags":[]},{"location":"api-reference/","level":1,"title":"API Reference","text":"<p>This page provides the complete API reference for the <code>geodistpy</code> package. All coordinates are expected in (latitude, longitude) format using the WGS 84 coordinate system.</p>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#distance-functions","level":2,"title":"Distance Functions","text":"","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#geodist","level":3,"title":"<code>geodist</code>","text":"<pre><code>geodist(coords1, coords2, metric=\"meter\", ellipsoid=\"WGS-84\")\n</code></pre> <p>Calculate the geodesic distance between two coordinates or two lists of coordinates using Vincenty's inverse formula (sub-millimeter accuracy).</p> <p>Parameters:</p> Parameter Type Description <code>coords1</code> <code>tuple</code> or <code>array-like</code> First coordinate(s) as <code>(lat, lon)</code> or array of shape <code>(n, 2)</code> <code>coords2</code> <code>tuple</code> or <code>array-like</code> Second coordinate(s) as <code>(lat, lon)</code> or array of shape <code>(n, 2)</code> <code>metric</code> <code>str</code> Unit of measurement: <code>'meter'</code>, <code>'km'</code>, <code>'mile'</code>, or <code>'nmi'</code>. Default: <code>'meter'</code> <code>ellipsoid</code> <code>str</code> or <code>tuple</code> Ellipsoid model: a named key from <code>ELLIPSOIDS</code> (e.g. <code>'WGS-84'</code>, <code>'GRS-80'</code>) or a custom <code>(a, f)</code> tuple. Default: <code>'WGS-84'</code> <p>Returns: <code>float</code> or <code>ndarray</code> — Distance(s) in the specified unit.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> — If coordinates don't have expected shape, or lat/lon values are out of range.</li> </ul> <p>Examples:</p> <pre><code>from geodistpy import geodist\n\n# Single pair\n&gt;&gt;&gt; geodist((52.5200, 13.4050), (48.8566, 2.3522), metric='km')\n878.389841013836\n\n# Multiple pairs\n&gt;&gt;&gt; coords1 = [(37.7749, -122.4194), (34.0522, -118.2437)]\n&gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n&gt;&gt;&gt; geodist(coords1, coords2, metric='mile')\narray([2449.92107243, 1745.82567572])\n\n# Same point returns zero\n&gt;&gt;&gt; geodist((37.7749, -122.4194), (37.7749, -122.4194))\n0.0\n</code></pre>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#greatcircle","level":3,"title":"<code>greatcircle</code>","text":"<pre><code>greatcircle(coords1, coords2, metric=\"meter\")\n</code></pre> <p>Calculate the distance between two coordinates using the Great Circle approximation with Andoyer-Lambert flattening correction (~19 m mean accuracy).</p> <p>Parameters:</p> Parameter Type Description <code>coords1</code> <code>tuple</code> or <code>array-like</code> First coordinate(s) as <code>(lat, lon)</code> or array of shape <code>(n, 2)</code> <code>coords2</code> <code>tuple</code> or <code>array-like</code> Second coordinate(s) as <code>(lat, lon)</code> or array of shape <code>(n, 2)</code> <code>metric</code> <code>str</code> Unit of measurement: <code>'meter'</code>, <code>'km'</code>, <code>'mile'</code>, or <code>'nmi'</code>. Default: <code>'meter'</code> <p>Returns: <code>float</code> or <code>ndarray</code> — Distance(s) in the specified unit.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> — If coordinates don't have expected shape, or lat/lon values are out of range.</li> </ul> <p>Note</p> <p>The Great Circle formula with Andoyer-Lambert correction assumes an oblate spheroid (WGS84 flattening). It is faster than Vincenty but less accurate (~19 m mean error vs ~9 µm).</p>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#matrix-functions","level":2,"title":"Matrix Functions","text":"","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#geodist_matrix","level":3,"title":"<code>geodist_matrix</code>","text":"<pre><code>geodist_matrix(coords1, coords2=None, metric=\"meter\", ellipsoid=\"WGS-84\")\n</code></pre> <p>Compute a pairwise distance matrix between all coordinate combinations using Vincenty's inverse formula with Numba-parallel execution.</p> <ul> <li>If only <code>coords1</code> is given: computes distances between all pairs in <code>coords1</code> → <code>dist[i, j] = distance(X[i], X[j])</code></li> <li>If <code>coords2</code> is also given: computes cross-distances → <code>dist[i, j] = distance(XA[i], XB[j])</code></li> </ul> <p>Parameters:</p> Parameter Type Description <code>coords1</code> <code>list of tuples</code> or <code>array-like</code> Coordinates as <code>[(lat, lon), ...]</code> or array of shape <code>(n, 2)</code> <code>coords2</code> <code>list of tuples</code> or <code>None</code> Optional second set of coordinates. Default: <code>None</code> <code>metric</code> <code>str</code> Unit of measurement: <code>'meter'</code>, <code>'km'</code>, <code>'mile'</code>, or <code>'nmi'</code>. Default: <code>'meter'</code> <code>ellipsoid</code> <code>str</code> or <code>tuple</code> Ellipsoid model: a named key from <code>ELLIPSOIDS</code> or a custom <code>(a, f)</code> tuple. Default: <code>'WGS-84'</code> <p>Returns: <code>ndarray</code> — Distance matrix.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> — If coordinates don't have expected shape, or lat/lon values are out of range.</li> </ul> <p>Examples:</p> <pre><code>from geodistpy import geodist_matrix\n\n# Self-distance matrix\n&gt;&gt;&gt; coords = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n&gt;&gt;&gt; geodist_matrix(coords, metric='km')\narray([[   0.        ,  878.38984101, 8786.58652276],\n       [ 878.38984101,    0.        , 9525.03650888],\n       [8786.58652276, 9525.03650888,    0.        ]])\n\n# Cross-distance matrix\n&gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n&gt;&gt;&gt; geodist_matrix(coords, coords2, metric='mile')\narray([[ 3060.81391478, 2437.78157493],\n       [ 4290.62813902, 1745.82567572],\n       [ 2449.92107243, 1746.57308007]])\n</code></pre>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#greatcircle_matrix","level":3,"title":"<code>greatcircle_matrix</code>","text":"<pre><code>greatcircle_matrix(coords1, coords2=None, metric=\"meter\")\n</code></pre> <p>Compute a pairwise distance matrix using the Great Circle approximation with Andoyer-Lambert correction and Numba-parallel execution.</p> <ul> <li>If only <code>coords1</code> is given: computes distances between all pairs in <code>coords1</code></li> <li>If <code>coords2</code> is also given: computes cross-distances</li> </ul> <p>Parameters:</p> Parameter Type Description <code>coords1</code> <code>list of tuples</code> or <code>array-like</code> Coordinates as <code>[(lat, lon), ...]</code> or array of shape <code>(n, 2)</code> <code>coords2</code> <code>list of tuples</code> or <code>None</code> Optional second set of coordinates. Default: <code>None</code> <code>metric</code> <code>str</code> Unit of measurement: <code>'meter'</code>, <code>'km'</code>, <code>'mile'</code>, or <code>'nmi'</code>. Default: <code>'meter'</code> <p>Returns: <code>ndarray</code> — Distance matrix.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> — If coordinates don't have expected shape, or lat/lon values are out of range.</li> </ul> <p>Examples:</p> <pre><code>from geodistpy import greatcircle_matrix\n\n# Self-distance matrix\n&gt;&gt;&gt; coords = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n&gt;&gt;&gt; greatcircle_matrix(coords, metric='km')\narray([[   0.        ,  878.38984101, 8786.58652276],\n       [ 878.38984101,    0.        , 9525.03650888],\n       [8786.58652276, 9525.03650888,    0.        ]])\n</code></pre>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#spatial-query-functions","level":2,"title":"Spatial Query Functions","text":"","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#bearing","level":3,"title":"<code>bearing</code>","text":"<pre><code>bearing(point1, point2, ellipsoid=\"WGS-84\")\n</code></pre> <p>Compute the initial bearing (forward azimuth) from point1 to point2 on an ellipsoid using Vincenty's inverse formula. The bearing is measured clockwise from true north and returned in the range [0, 360) degrees.</p> <p>Parameters:</p> Parameter Type Description <code>point1</code> <code>tuple</code> Starting point as <code>(lat, lon)</code> in degrees <code>point2</code> <code>tuple</code> Destination point as <code>(lat, lon)</code> in degrees <code>ellipsoid</code> <code>str</code> or <code>tuple</code> Ellipsoid model: a named key from <code>ELLIPSOIDS</code> or a custom <code>(a, f)</code> tuple. Default: <code>'WGS-84'</code> <p>Returns: <code>float</code> — Forward azimuth in degrees (0–360).</p> <p>Examples:</p> <pre><code>from geodistpy import bearing\n\n&gt;&gt;&gt; bearing((52.5200, 13.4050), (48.8566, 2.3522))   # Berlin → Paris\n245.58...\n\n&gt;&gt;&gt; bearing((0.0, 0.0), (0.0, 1.0))                  # Due east on the equator\n90.0\n</code></pre>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#destination","level":3,"title":"<code>destination</code>","text":"<pre><code>destination(point, bearing_deg, distance, metric=\"meter\", ellipsoid=\"WGS-84\")\n</code></pre> <p>Compute the destination point given a starting point, initial bearing, and distance along the geodesic on an ellipsoid (Vincenty direct formula).</p> <p>Parameters:</p> Parameter Type Description <code>point</code> <code>tuple</code> Starting point as <code>(lat, lon)</code> in degrees <code>bearing_deg</code> <code>float</code> Initial bearing in degrees clockwise from north <code>distance</code> <code>float</code> Distance to travel in the unit specified by <code>metric</code> <code>metric</code> <code>str</code> Unit for distance: <code>'meter'</code>, <code>'km'</code>, <code>'mile'</code>, or <code>'nmi'</code>. Default: <code>'meter'</code> <code>ellipsoid</code> <code>str</code> or <code>tuple</code> Ellipsoid model: a named key from <code>ELLIPSOIDS</code> or a custom <code>(a, f)</code> tuple. Default: <code>'WGS-84'</code> <p>Returns: <code>tuple</code> — Destination point as <code>(latitude, longitude)</code> in degrees.</p> <p>Examples:</p> <pre><code>from geodistpy import destination\n\n&gt;&gt;&gt; destination((52.5200, 13.4050), 245.0, 879.0, metric='km')\n(48.85..., 2.35...)\n\n&gt;&gt;&gt; destination((0.0, 0.0), 90.0, 111.32, metric='km')\n(0.0, 1.0...)\n</code></pre>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#interpolate","level":3,"title":"<code>interpolate</code>","text":"<pre><code>interpolate(point1, point2, n_points=1, ellipsoid=\"WGS-84\")\n</code></pre> <p>Return evenly-spaced waypoints along the geodesic from point1 to point2 on an ellipsoid. When <code>n_points=1</code> the function returns the midpoint. For <code>n_points=N</code> it returns N interior points that divide the geodesic into N + 1 equal-length segments (endpoints are not included).</p> <p>Parameters:</p> Parameter Type Description <code>point1</code> <code>tuple</code> Start point as <code>(lat, lon)</code> in degrees <code>point2</code> <code>tuple</code> End point as <code>(lat, lon)</code> in degrees <code>n_points</code> <code>int</code> Number of interior waypoints to return. Default: <code>1</code> <code>ellipsoid</code> <code>str</code> or <code>tuple</code> Ellipsoid model: a named key from <code>ELLIPSOIDS</code> or a custom <code>(a, f)</code> tuple. Default: <code>'WGS-84'</code> <p>Returns: <code>list of tuples</code> — Waypoints as <code>[(lat, lon), ...]</code>, ordered from point1 towards point2.</p> <p>Examples:</p> <pre><code>from geodistpy import interpolate\n\n&gt;&gt;&gt; interpolate((0.0, 0.0), (0.0, 10.0), n_points=1)\n[(0.0, 5.0...)]\n\n&gt;&gt;&gt; interpolate((0.0, 0.0), (0.0, 10.0), n_points=4)\n[(0.0, 2.0...), (0.0, 4.0...), (0.0, 6.0...), (0.0, 8.0...)]\n</code></pre>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#midpoint","level":3,"title":"<code>midpoint</code>","text":"<pre><code>midpoint(point1, point2, ellipsoid=\"WGS-84\")\n</code></pre> <p>Return the geodesic midpoint between two points on an ellipsoid. Convenience wrapper around <code>interpolate(point1, point2, n_points=1)</code>.</p> <p>Parameters:</p> Parameter Type Description <code>point1</code> <code>tuple</code> First point as <code>(lat, lon)</code> in degrees <code>point2</code> <code>tuple</code> Second point as <code>(lat, lon)</code> in degrees <code>ellipsoid</code> <code>str</code> or <code>tuple</code> Ellipsoid model: a named key from <code>ELLIPSOIDS</code> or a custom <code>(a, f)</code> tuple. Default: <code>'WGS-84'</code> <p>Returns: <code>tuple</code> — Midpoint as <code>(latitude, longitude)</code> in degrees.</p> <p>Examples:</p> <pre><code>from geodistpy import midpoint\n\n&gt;&gt;&gt; midpoint((0.0, 0.0), (0.0, 10.0))\n(0.0, 5.0...)\n</code></pre>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#point_in_radius","level":3,"title":"<code>point_in_radius</code>","text":"<pre><code>point_in_radius(center, candidates, radius, metric=\"meter\", ellipsoid=\"WGS-84\")\n</code></pre> <p>Find all candidate points that lie within a given geodesic radius of a center point on an ellipsoid. Useful for geofencing, store-locator queries, and spatial filtering.</p> <p>Parameters:</p> Parameter Type Description <code>center</code> <code>tuple</code> Reference point as <code>(lat, lon)</code> in degrees <code>candidates</code> <code>array-like</code> Array of candidate points <code>[(lat, lon), ...]</code> with shape <code>(n, 2)</code> <code>radius</code> <code>float</code> Radius threshold in the unit specified by <code>metric</code> <code>metric</code> <code>str</code> Unit for radius: <code>'meter'</code>, <code>'km'</code>, <code>'mile'</code>, or <code>'nmi'</code>. Default: <code>'meter'</code> <code>ellipsoid</code> <code>str</code> or <code>tuple</code> Ellipsoid model: a named key from <code>ELLIPSOIDS</code> or a custom <code>(a, f)</code> tuple. Default: <code>'WGS-84'</code> <p>Returns: <code>tuple (indices, distances)</code> — indices is an ndarray of int (indices of points within the radius); distances is an ndarray of float (corresponding distances).</p> <p>Examples:</p> <pre><code>from geodistpy import point_in_radius\n\n&gt;&gt;&gt; pts = [(48.8566, 2.3522), (40.7128, -74.006), (51.5074, -0.1278)]\n&gt;&gt;&gt; idx, dists = point_in_radius((52.5200, 13.4050), pts, 1000, metric='km')\n&gt;&gt;&gt; idx\narray([0, 2])    # Paris and London are within 1000 km of Berlin\n</code></pre>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#geodesic_knn","level":3,"title":"<code>geodesic_knn</code>","text":"<pre><code>geodesic_knn(point, candidates, k=1, metric=\"meter\", ellipsoid=\"WGS-84\")\n</code></pre> <p>Find the k nearest neighbours to a query point among candidates using exact geodesic (Vincenty) distances on an ellipsoid. This fills the gap left by <code>sklearn.neighbors.BallTree</code> which only supports the haversine (spherical) metric.</p> <p>Parameters:</p> Parameter Type Description <code>point</code> <code>tuple</code> Query point as <code>(lat, lon)</code> in degrees <code>candidates</code> <code>array-like</code> Array of candidate points <code>[(lat, lon), ...]</code> with shape <code>(n, 2)</code> <code>k</code> <code>int</code> Number of nearest neighbours to return. Default: <code>1</code> <code>metric</code> <code>str</code> Unit for returned distances: <code>'meter'</code>, <code>'km'</code>, <code>'mile'</code>, or <code>'nmi'</code>. Default: <code>'meter'</code> <code>ellipsoid</code> <code>str</code> or <code>tuple</code> Ellipsoid model: a named key from <code>ELLIPSOIDS</code> or a custom <code>(a, f)</code> tuple. Default: <code>'WGS-84'</code> <p>Returns: <code>tuple (indices, distances)</code> — indices is an ndarray of int, shape <code>(k,)</code> (indices of the k closest points, ordered nearest-first); distances is an ndarray of float, shape <code>(k,)</code>.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> — If <code>k &lt; 1</code>, <code>k &gt; n</code>, or coordinates are out of range.</li> </ul> <p>Examples:</p> <pre><code>from geodistpy import geodesic_knn\n\n&gt;&gt;&gt; pts = [(48.8566, 2.3522), (40.7128, -74.006), (51.5074, -0.1278)]\n&gt;&gt;&gt; idx, dists = geodesic_knn((52.5200, 13.4050), pts, k=2, metric='km')\n&gt;&gt;&gt; idx\narray([0, 2])    # Paris (~880 km) and London (~930 km) are nearest\n</code></pre>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#supported-metrics","level":2,"title":"Supported Metrics","text":"<p>All distance and spatial query functions accept a <code>metric</code> parameter with one of the following values:</p> Value Unit Conversion <code>'meter'</code> Meters Base unit <code>'km'</code> Kilometers ÷ 1,000 <code>'mile'</code> Statute miles ÷ 1,609.344 <code>'nmi'</code> Nautical miles ÷ 1,852","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#supported-ellipsoids","level":2,"title":"Supported Ellipsoids","text":"<p>All Vincenty-based functions (<code>geodist</code>, <code>geodist_matrix</code>, <code>bearing</code>, <code>destination</code>, <code>interpolate</code>, <code>midpoint</code>, <code>point_in_radius</code>, <code>geodesic_knn</code>) accept an optional <code>ellipsoid</code> parameter. You can pass either:</p> <ul> <li>A named string from the built-in <code>ELLIPSOIDS</code> dictionary</li> <li>A custom tuple <code>(semi_major_axis, flattening)</code> where a is in meters</li> </ul>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#built-in-ellipsoids-ellipsoids","level":3,"title":"Built-in Ellipsoids (<code>ELLIPSOIDS</code>)","text":"<pre><code>from geodistpy import ELLIPSOIDS\nprint(ELLIPSOIDS)\n</code></pre> Name Semi-major axis a (m) Flattening f Use Case <code>'WGS-84'</code> 6,378,137.0 1 / 298.257223563 GPS, global mapping (default) <code>'GRS-80'</code> 6,378,137.0 1 / 298.257222101 Geodetic reference, ITRF <code>'Airy (1830)'</code> 6,377,563.396 1 / 299.3249646 Ordnance Survey Great Britain <code>'Intl 1924'</code> 6,378,388.0 1 / 297.0 European Datum 1950 <code>'Clarke (1880)'</code> 6,378,249.145 1 / 293.465 Africa, France (historic) <code>'GRS-67'</code> 6,378,160.0 1 / 298.25 South American Datum 1969","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"api-reference/#examples","level":3,"title":"Examples","text":"<pre><code>from geodistpy import geodist, bearing, destination, ELLIPSOIDS\n\nberlin = (52.5200, 13.4050)\nparis  = (48.8566, 2.3522)\n\n# Named ellipsoid\nd = geodist(berlin, paris, metric='km', ellipsoid='GRS-80')\nb = bearing(berlin, paris, ellipsoid='Airy (1830)')\n\n# Custom ellipsoid as (a, f) tuple\nd = geodist(berlin, paris, ellipsoid=(6378137.0, 1/298.257223563))\nlat, lon = destination(berlin, 90.0, 500, metric='km', ellipsoid=(6378388.0, 1/297.0))\n</code></pre>","path":["API Reference – Geodistpy Functions & Parameters"],"tags":[]},{"location":"bearing-destination/","level":1,"title":"Bearing &amp; Destination","text":"<p>This guide covers two complementary operations on the WGS-84 ellipsoid:</p> <ul> <li>Bearing (inverse problem): Given two points, what is the initial direction from one to the other?</li> <li>Destination (direct problem): Given a starting point, a direction, and a distance, where do you end up?</li> </ul> <p>Together, these complete Vincenty's inverse/direct pair and enable powerful geospatial workflows.</p>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#understanding-bearing","level":2,"title":"Understanding Bearing","text":"<p>A bearing (or forward azimuth) is the initial compass direction you would travel from point A to reach point B along the shortest path on the Earth's surface (the geodesic). It is measured in degrees clockwise from true north:</p> Bearing Direction 0° North 90° East 180° South 270° West <p>Bearing changes along a geodesic</p> <p>On an ellipsoid, the bearing is not constant along a geodesic (unlike a rhumb line). The bearing at point A towards B differs from the bearing at B towards A by roughly 180° — but not exactly, due to the Earth's curvature and flattening. This is why Vincenty's inverse formula computes both a forward azimuth and a back azimuth.</p>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#basic-usage","level":3,"title":"Basic Usage","text":"<pre><code>from geodistpy import bearing\n\n# Berlin → Paris\nb = bearing((52.5200, 13.4050), (48.8566, 2.3522))\nprint(f\"Bearing: {b:.2f}°\")  # ~245.58° (roughly southwest)\n\n# Cardinal directions on the equator\nprint(bearing((0, 0), (0, 1)))    # 90.0  (due east)\nprint(bearing((0, 0), (1, 0)))    # 0.0   (due north)\nprint(bearing((1, 0), (0, 0)))    # 180.0 (due south)\nprint(bearing((0, 1), (0, 0)))    # 270.0 (due west)\n</code></pre>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#bearing-is-not-symmetric","level":3,"title":"Bearing is Not Symmetric","text":"<p>The bearing from A → B is different from B → A:</p> <pre><code>from geodistpy import bearing\n\nberlin = (52.5200, 13.4050)\nparis  = (48.8566, 2.3522)\n\nb_ab = bearing(berlin, paris)\nb_ba = bearing(paris, berlin)\n\nprint(f\"Berlin → Paris: {b_ab:.2f}°\")   # ~245.58°\nprint(f\"Paris → Berlin: {b_ba:.2f}°\")   # ~58.29°\nprint(f\"Difference: {abs(b_ab - b_ba):.2f}°\")  # ~187.29° (not exactly 180°)\n</code></pre> <p>This difference from 180° arises because the geodesic curves on the ellipsoid.</p>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#use-cases","level":3,"title":"Use Cases","text":"<ul> <li>Navigation: Determine which direction to travel</li> <li>Compass headings: Convert geodesic paths to bearing instructions</li> <li>Sector analysis: Classify the direction of movement (N/S/E/W quadrant)</li> <li>Antenna alignment: Point directional antennas towards a target</li> </ul>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#understanding-destination","level":2,"title":"Understanding Destination","text":"<p>The destination function solves Vincenty's direct problem: given a starting point, an initial bearing, and a distance, it computes the endpoint.</p>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#basic-usage_1","level":3,"title":"Basic Usage","text":"<pre><code>from geodistpy import destination\n\n# Travel 500 km due east from Berlin\nlat, lon = destination((52.5200, 13.4050), 90.0, 500, metric='km')\nprint(f\"Destination: ({lat:.4f}, {lon:.4f})\")\n\n# Travel 100 miles due north from the equator\nlat, lon = destination((0.0, 0.0), 0.0, 100, metric='mile')\nprint(f\"Destination: ({lat:.4f}, {lon:.4f})\")\n</code></pre>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#supported-distance-units","level":3,"title":"Supported Distance Units","text":"<p>The <code>metric</code> parameter controls the unit of the <code>distance</code> argument:</p> <pre><code>from geodistpy import destination\n\nstart = (52.5200, 13.4050)\n\n# All produce the same destination:\ndestination(start, 90.0, 500_000, metric='meter')\ndestination(start, 90.0, 500, metric='km')\ndestination(start, 90.0, 500 / 1.609344, metric='mile')\ndestination(start, 90.0, 500 / 1.852, metric='nmi')\n</code></pre>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#longitude-normalisation","level":3,"title":"Longitude Normalisation","text":"<p>Destination longitudes are automatically normalised to the range [-180, 180]:</p> <pre><code>from geodistpy import destination\n\n# Travel east past the antimeridian\nlat, lon = destination((0.0, 170.0), 90.0, 2000, metric='km')\nprint(f\"lon = {lon:.2f}\")  # Normalised to [-180, 180]\n</code></pre>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#roundtrip-bearing-destination","level":2,"title":"Roundtrip: Bearing → Destination","text":"<p>The <code>bearing</code> and <code>destination</code> functions are inverses of each other. You can verify this with a roundtrip:</p> <pre><code>from geodistpy import bearing, destination, geodist\n\n# Given two points\nA = (52.5200, 13.4050)  # Berlin\nB = (48.8566, 2.3522)   # Paris\n\n# Step 1: Compute bearing and distance\nb = bearing(A, B)\nd = geodist(A, B, metric='km')\nprint(f\"Bearing: {b:.4f}°, Distance: {d:.2f} km\")\n\n# Step 2: Reconstruct B using destination\nB_reconstructed = destination(A, b, d, metric='km')\nprint(f\"Original:      ({B[0]:.4f}, {B[1]:.4f})\")\nprint(f\"Reconstructed: ({B_reconstructed[0]:.4f}, {B_reconstructed[1]:.4f})\")\n# The two should match to ~4 decimal places\n</code></pre>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#real-world-example-search-sector","level":2,"title":"Real-World Example: Search Sector","text":"<p>Create a search area by projecting points at various bearings from a centre:</p> <pre><code>from geodistpy import destination\n\n# Centre of search area\ncentre = (48.8566, 2.3522)  # Paris\nradius_km = 50\n\n# Generate 8 compass points around the centre\ncompass = {\n    'N': 0, 'NE': 45, 'E': 90, 'SE': 135,\n    'S': 180, 'SW': 225, 'W': 270, 'NW': 315,\n}\n\nfor name, bearing_deg in compass.items():\n    lat, lon = destination(centre, bearing_deg, radius_km, metric='km')\n    print(f\"  {name:&gt;2}: ({lat:.4f}, {lon:.4f})\")\n</code></pre>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#how-it-works-vincentys-formulas","level":2,"title":"How It Works: Vincenty's Formulas","text":"","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#inverse-bearing","level":3,"title":"Inverse (Bearing)","text":"<p>Vincenty's inverse formula iteratively solves for the geodesic distance and azimuths between two points on an ellipsoid. The key outputs are:</p> <ul> <li>s — geodesic distance</li> <li>α₁ — forward azimuth (bearing at start point)</li> <li>α₂ — back azimuth (bearing at end point)</li> </ul> <p>Geodistpy's <code>geodesic_vincenty_inverse_full()</code> returns all three in a single Numba-JIT pass. The high-level <code>bearing()</code> function extracts just the forward azimuth.</p>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#direct-destination","level":3,"title":"Direct (Destination)","text":"<p>Vincenty's direct formula takes a starting point, forward azimuth α₁, and distance s, then iteratively computes:</p> <ul> <li>φ₂, λ₂ — latitude and longitude of the destination point</li> <li>α₂ — back azimuth at the destination</li> </ul> <p>Geodistpy's <code>geodesic_vincenty_direct()</code> implements this as a Numba-JIT function for maximum performance.</p>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#convergence-and-fallback","level":3,"title":"Convergence and Fallback","text":"<p>Both formulas iterate until convergence (threshold: 10⁻¹¹). In the rare case (~0.01%) that the inverse formula fails to converge (typically near-antipodal points), geodistpy falls back to the slower but always-convergent GeographicLib algorithm.</p>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#performance","level":2,"title":"Performance","text":"<p>Both <code>bearing()</code> and <code>destination()</code> benefit from Numba JIT compilation:</p> Operation Typical Time Notes <code>bearing()</code> ~0.5 µs Same cost as distance computation <code>destination()</code> ~0.5 µs Vincenty direct converges quickly <p>These are fast enough for real-time applications with thousands of calls per second.</p>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"bearing-destination/#using-different-ellipsoids","level":2,"title":"Using Different Ellipsoids","text":"<p>Both <code>bearing()</code> and <code>destination()</code> accept an optional <code>ellipsoid</code> parameter. By default, WGS-84 is used. You can choose from six built-in ellipsoids or pass a custom <code>(a, f)</code> tuple:</p> <pre><code>from geodistpy import bearing, destination, ELLIPSOIDS\n\n# Bearing on the GRS-80 ellipsoid\nb = bearing((52.5200, 13.4050), (48.8566, 2.3522), ellipsoid='GRS-80')\nprint(f\"GRS-80 bearing: {b:.4f}°\")\n\n# Destination on the Airy 1830 ellipsoid\nlat, lon = destination((52.5200, 13.4050), 90.0, 500, metric='km', ellipsoid='Airy (1830)')\nprint(f\"Airy destination: ({lat:.4f}, {lon:.4f})\")\n\n# Custom ellipsoid as (semi_major_axis, flattening) tuple\nlat, lon = destination((0, 0), 45.0, 1000, metric='km', ellipsoid=(6378388.0, 1/297.0))\nprint(f\"Custom destination: ({lat:.4f}, {lon:.4f})\")\n\n# Available named ellipsoids\nprint(ELLIPSOIDS.keys())\n# dict_keys(['WGS-84', 'GRS-80', 'Airy (1830)', 'Intl 1924', 'Clarke (1880)', 'GRS-67'])\n</code></pre> <p>Supported named ellipsoids: WGS-84 (default), GRS-80, Airy (1830), Intl 1924, Clarke (1880), GRS-67.</p>","path":["Bearing & Destination – Vincenty Direct/Inverse on the WGS-84 Ellipsoid"],"tags":[]},{"location":"explanation/","level":1,"title":"Explanation","text":"<p>Geodistpy is a powerful Python library designed for lightning-fast geospatial distance computations. It uses Vincenty's inverse formula accelerated with Numba JIT compilation and parallel execution to achieve extreme performance, while maintaining sub-millimeter accuracy on the WGS84 ellipsoid.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#speed-comparison","level":2,"title":"Speed Comparison","text":"<pre><code># Import libraries\nfrom geopy.distance import geodesic as geodesic_geopy\nfrom geographiclib.geodesic import Geodesic as geodesic_gglib\nfrom geodistpy.geodesic import geodesic_vincenty\n\n# Define two coordinates\ncoord1 = (52.5200, 13.4050)  # Berlin\ncoord2 = (48.8566, 2.3522)   # Paris\n\n# Calculate distance with Geopy (based on Geographiclib)\ndistance_geopy = geodesic_geopy(coord1, coord2).meters\n\n# Calculate distance with Geographiclib\ndistance_gglib = geodesic_gglib.WGS84.Inverse(coord1[0], coord1[1], coord2[0], coord2[1])['s12']\n\n# Calculate distance with Geodistpy\ndistance_geodistpy = geodesic_vincenty(coord1, coord2)\n\n# Print the results\nprint(f\"Distance between Berlin and Paris:\")\nprint(f\"Geopy: {distance_geopy} meters\")\nprint(f\"Geographiclib: {distance_gglib} meters\")\nprint(f\"Geodistpy: {distance_geodistpy} meters\")\n</code></pre>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#single-pair-performance-10000-calls-best-of-3","level":3,"title":"Single-Pair Performance (10,000 calls, best of 3)","text":"Library Total Time Per Call Geopy ~636 ms ~64 µs Geographiclib ~406 ms ~41 µs Geodistpy (Vincenty+Numba) ~3.7 ms ~0.4 µs <ul> <li>Geodistpy is ~171x faster than Geopy</li> <li>Geodistpy is ~109x faster than Geographiclib</li> </ul>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#pairwise-distance-matrix-nn","level":3,"title":"Pairwise Distance Matrix (N×N)","text":"<p>For matrix computations, Geodistpy uses Numba-parallel loops instead of scipy callbacks, yielding massive speedups:</p> N points Unique Pairs Geopy Geographiclib Geodistpy Speedup vs Geopy 50 1,225 87 ms 58 ms 4.1 ms 21x 100 4,950 363 ms 236 ms 0.59 ms 613x 200 19,900 1.44 s 930 ms 1.17 ms 1,230x","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#accuracy-geographiclib-as-reference-5000-random-pairs","level":3,"title":"Accuracy (Geographiclib as reference, 5,000 random pairs)","text":"Method Mean Error (m) Max Error (m) Mean Rel. Error Geodistpy (Vincenty) 0.000009 0.000108 1.03e-12 Geopy (geodesic) 0.000000 0.000000 4.40e-17 Geodistpy (Great Circle) 19.23 462.88 2.34e-06 <p>Note: Geopy shows zero error because it wraps Geographiclib — it's the same algorithm. Geodistpy's Vincenty mean error of 9 micrometers is negligible. The Great Circle method uses an Andoyer-Lambert flattening correction that reduces error from ~13 km (pure sphere) to ~19 m — a 700x improvement.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#great-circle-vs-geodesic-trade-off","level":3,"title":"Great Circle vs Geodesic Trade-off","text":"Method Time (10,000 calls) Mean Error Use Case Great Circle + Andoyer-Lambert 3.0 ms ~19 m Fast with good accuracy Vincenty Geodesic 4.9 ms ~0.009 mm Maximum precision","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#performance-summary","level":2,"title":"Performance Summary","text":"<ul> <li>Single-pair: ~0.4 µs per call (171x faster than Geopy, 109x faster than Geographiclib)</li> <li>Matrix (N=200): 1.17 ms for 19,900 pairs (1,230x faster than Geopy)</li> <li>Vincenty accuracy: sub-millimeter (mean error = 9 µm)</li> <li>Great Circle accuracy: ~19 m mean error with Andoyer-Lambert flattening correction</li> <li>All edge cases handled: antipodal points, poles, date line crossings, short distances</li> </ul>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#key-implementation-details","level":2,"title":"Key Implementation Details","text":"","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#vincentys-inverse-formula","level":3,"title":"Vincenty's Inverse Formula","text":"<p>The core algorithm solves the inverse geodetic problem on the WGS84 ellipsoid using Vincenty's iterative method with 4<sup>th</sup>-order series expansions for the A and B Helmert coefficients. It is JIT-compiled with Numba using <code>fastmath=True</code> for additional floating-point optimizations.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#andoyer-lambert-flattening-correction","level":3,"title":"Andoyer-Lambert Flattening Correction","text":"<p>The Great Circle function applies a first-order correction for Earth's oblateness (WGS84 flattening f = 1/298.257223563). This dramatically improves accuracy compared to a pure spherical model while adding minimal computational cost.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#numba-parallel-matrix-computation","level":3,"title":"Numba Parallel Matrix Computation","text":"<p>Distance matrices use <code>@jit(parallel=True)</code> with <code>prange</code> for automatic multi-threaded execution, eliminating the overhead of Python-level callback functions that plague scipy-based approaches.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#vincenty-direct-formula-destination","level":3,"title":"Vincenty Direct Formula (Destination)","text":"<p>The <code>destination()</code> function implements Vincenty's direct formula, which is the complement to the inverse formula. Given a starting point, initial bearing, and distance, it computes the destination point on the WGS-84 ellipsoid. Both the inverse and direct Vincenty functions are JIT-compiled with Numba.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#bearing-forward-azimuth","level":3,"title":"Bearing (Forward Azimuth)","text":"<p>The <code>bearing()</code> function exposes the forward azimuth already computed internally by Vincenty's inverse iteration. A full inverse variant (<code>geodesic_vincenty_inverse_full</code>) returns (distance, forward_azimuth, back_azimuth) in a single pass, making bearing extraction essentially free.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#geodesic-interpolation","level":3,"title":"Geodesic Interpolation","text":"<p>The <code>interpolate()</code> and <code>midpoint()</code> functions combine the inverse and direct Vincenty formulas: first computing the total distance and azimuth via inverse, then stepping along the geodesic using direct to produce evenly-spaced waypoints. This is useful for route visualization and great-circle path rendering.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#spatial-queries-k-nn-and-point-in-radius","level":3,"title":"Spatial Queries (k-NN and Point-in-Radius)","text":"<p>The <code>geodesic_knn()</code> and <code>point_in_radius()</code> functions fill the gap left by sklearn's <code>BallTree</code> which only supports haversine (spherical) distances. These functions use exact Vincenty ellipsoidal distances, providing higher accuracy for geofencing, store-locator, and spatial filtering applications.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#multiple-ellipsoid-support","level":3,"title":"Multiple Ellipsoid Support","text":"<p>All distance, bearing, destination, interpolation, and spatial query functions accept an optional <code>ellipsoid</code> parameter. By default, WGS-84 is used. Six named ellipsoids are built in — WGS-84, GRS-80, Airy (1830), Intl 1924, Clarke (1880), and GRS-67 — and users can also pass any custom <code>(semi_major_axis, flattening)</code> tuple for specialised geodetic applications. The <code>_resolve_ellipsoid()</code> helper converts the user input into <code>(a, f)</code> floats that are threaded through every Numba-JIT function, so switching ellipsoids incurs no additional overhead.</p> <pre><code>from geodistpy import geodist, ELLIPSOIDS\n\n# Named ellipsoid\nd = geodist((52.52, 13.405), (48.8566, 2.3522), metric='km', ellipsoid='GRS-80')\n\n# Custom (a, f) tuple\nd = geodist((52.52, 13.405), (48.8566, 2.3522), ellipsoid=(6378137.0, 1/298.257223563))\n\n# List available ellipsoids\nprint(ELLIPSOIDS.keys())\n</code></pre>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#context-and-background","level":2,"title":"Context and Background","text":"<p>The Python package <code>geodistpy</code> is a versatile library designed for geospatial calculations involving distances between geographical coordinates. It is built on the principles of geodesy and uses the WGS 84 coordinate system, which is commonly used in GPS and mapping applications.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#why-it-was-created","level":2,"title":"Why it was Created","text":"<p>The package was created to simplify and standardize geospatial distance calculations. Geographical distance calculations can be complex due to the curvature of the Earth's surface, and this library abstracts away those complexities, allowing users to focus on their specific geospatial tasks.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#examples-and-approaches","level":2,"title":"Examples and Approaches","text":"<p>Let's explore multiple examples and approaches to working with the <code>geodistpy</code> library:</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#example-1-calculating-distance-between-two-coordinates","level":3,"title":"Example 1: Calculating Distance Between Two Coordinates","text":"<pre><code>from geodistpy import geodist\n\n# Define two coordinates in (latitude, longitude) format\ncoord1 = (52.5200, 13.4050)  # Berlin, Germany\ncoord2 = (48.8566, 2.3522)   # Paris, France\n\n# Calculate the distance between the two coordinates in kilometers\ndistance_km = geodist(coord1, coord2, metric='km')\nprint(f\"Distance between Berlin and Paris: {distance_km} kilometers\")\n</code></pre>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#example-2-calculating-distance-between-multiple-coordinates","level":3,"title":"Example 2: Calculating Distance Between Multiple Coordinates","text":"<pre><code>from geodistpy import greatcircle_matrix\n\n# Define a list of coordinates\ncoords = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n\n# Calculate the distance matrix between all pairs of coordinates in miles\ndistance_matrix_miles = greatcircle_matrix(coords, metric='mile')\nprint(\"Distance matrix in miles:\")\nprint(distance_matrix_miles)\n</code></pre>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#example-3-working-with-different-metrics","level":3,"title":"Example 3: Working with Different Metrics","text":"<p>The <code>geodistpy</code> library allows you to work with various distance metrics, such as meters, kilometers, miles, and nautical miles. You can easily switch between them by specifying the <code>metric</code> parameter.</p> <pre><code>from geodistpy import geodist\n\ncoord1 = (52.5200, 13.4050)  # Berlin, Germany\ncoord2 = (48.8566, 2.3522)   # Paris, France\n\n# Calculate the distance in meters\ndistance_meters = geodist(coord1, coord2, metric='meter')\n\n# Calculate the distance in nautical miles\ndistance_nautical_miles = geodist(coord1, coord2, metric='nmi')\n\nprint(f\"Distance in meters: {distance_meters}\")\nprint(f\"Distance in nautical miles: {distance_nautical_miles}\")\n</code></pre>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#example-4-bearing-and-destination","level":3,"title":"Example 4: Bearing and Destination","text":"<p>Compute the initial bearing from one point to another, or find where you arrive after travelling a given distance at a given bearing:</p> <pre><code>from geodistpy import bearing, destination\n\nberlin = (52.5200, 13.4050)\nparis  = (48.8566, 2.3522)\n\n# Forward azimuth from Berlin to Paris\nb = bearing(berlin, paris)\nprint(f\"Bearing Berlin → Paris: {b:.2f}°\")  # ~245.58°\n\n# Travel 500 km due east from Berlin\nlat, lon = destination(berlin, 90.0, 500, metric='km')\nprint(f\"Destination: ({lat:.4f}, {lon:.4f})\")\n</code></pre>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#example-5-geodesic-midpoint-and-waypoints","level":3,"title":"Example 5: Geodesic Midpoint and Waypoints","text":"<p>Generate waypoints along a geodesic path — useful for route visualisation:</p> <pre><code>from geodistpy import midpoint, interpolate\n\nberlin = (52.5200, 13.4050)\nparis  = (48.8566, 2.3522)\n\n# Geodesic midpoint\nmid = midpoint(berlin, paris)\nprint(f\"Midpoint: ({mid[0]:.4f}, {mid[1]:.4f})\")\n\n# 4 evenly-spaced interior waypoints\nwaypoints = interpolate(berlin, paris, n_points=4)\nfor i, wp in enumerate(waypoints, 1):\n    print(f\"  Waypoint {i}: ({wp[0]:.4f}, {wp[1]:.4f})\")\n</code></pre>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#example-6-geofencing-with-point-in-radius","level":3,"title":"Example 6: Geofencing with Point-in-Radius","text":"<p>Find all points within a given geodesic radius:</p> <pre><code>from geodistpy import point_in_radius\n\ncities = [\n    (48.8566, 2.3522),    # Paris\n    (40.7128, -74.006),   # New York\n    (51.5074, -0.1278),   # London\n    (41.9028, 12.4964),   # Rome\n]\n\n# Which cities are within 1500 km of Berlin?\nidx, dists = point_in_radius((52.5200, 13.4050), cities, 1500, metric='km')\nprint(f\"Within 1500 km: indices {idx}, distances {dists.round(1)} km\")\n</code></pre>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#example-7-k-nearest-neighbours-on-the-ellipsoid","level":3,"title":"Example 7: k-Nearest Neighbours on the Ellipsoid","text":"<p>Find the closest points using exact Vincenty distances (not haversine):</p> <pre><code>from geodistpy import geodesic_knn\n\ncities = [\n    (48.8566, 2.3522),    # Paris\n    (40.7128, -74.006),   # New York\n    (51.5074, -0.1278),   # London\n    (41.9028, 12.4964),   # Rome\n]\n\nidx, dists = geodesic_knn((52.5200, 13.4050), cities, k=2, metric='km')\nprint(f\"2 nearest: indices {idx}, distances {dists.round(1)} km\")\n</code></pre>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"explanation/#conclusion","level":2,"title":"Conclusion","text":"<p>For applications that demand rapid and precise geospatial distance computations, Geodistpy is the clear choice. It offers exceptional speed improvements over both Geopy and Geographiclib, making it ideal for tasks involving large datasets or real-time geospatial applications. Despite its speed, Geodistpy maintains accuracy on par with Geographiclib, ensuring that fast calculations do not compromise precision.</p> <p>By adopting Geodistpy, you can significantly enhance the efficiency and performance of your geospatial projects. It is a valuable tool for geospatial professionals and developers seeking both speed and accuracy in their distance computations.</p> <p>To get started with Geodistpy, visit the Geodistpy and explore the documentation for comprehensive usage instructions.</p>","path":["Performance Benchmarks & Implementation – Geodistpy vs Geopy vs Geographiclib"],"tags":[]},{"location":"getting-started/","level":1,"title":"Getting Started","text":"","path":["Getting Started with Geodistpy – Installation & Quick Start"],"tags":[]},{"location":"getting-started/#ellipsoid-support","level":2,"title":"Ellipsoid Support","text":"<p>All distance, bearing, destination, interpolation, and spatial query functions accept an optional <code>ellipsoid</code> parameter. By default, WGS-84 is used.</p> <pre><code>from geodistpy import geodist, ELLIPSOIDS\n\n# Use a named ellipsoid\nd = geodist((52.52, 13.405), (48.8566, 2.3522), metric=\"km\", ellipsoid=\"GRS-80\")\n\n# Use a custom (a, f) tuple\nd = geodist((52.52, 13.405), (48.8566, 2.3522), ellipsoid=(6378137.0, 1/298.257223563))\n\n# See all available ellipsoids\nprint(ELLIPSOIDS.keys())\n# dict_keys(['WGS-84', 'GRS-80', 'Airy (1830)', 'Intl 1924', 'Clarke (1880)', 'GRS-67'])\n</code></pre> <p>Supported named ellipsoids: WGS-84 (default), GRS-80, Airy (1830), Intl 1924, Clarke (1880), GRS-67. You can also pass any <code>(semi_major_axis, flattening)</code> tuple.</p>","path":["Getting Started with Geodistpy – Installation & Quick Start"],"tags":[]},{"location":"getting-started/#installation","level":2,"title":"Installation","text":"<p>You can install the <code>geodistpy</code> package using <code>pip</code>:</p> <pre><code>pip install geodistpy\n</code></pre>","path":["Getting Started with Geodistpy – Installation & Quick Start"],"tags":[]},{"location":"getting-started/#quick-start-guide","level":2,"title":"Quick Start Guide","text":"<p>The quickest way to start using the <code>geodistpy</code> package is to calculate the distance between two geographical coordinates. Here's how you can do it:</p> <pre><code>from geodistpy import geodist\n\n# Define two coordinates in (latitude, longitude) format\ncoord1 = (52.5200, 13.4050)  # Berlin, Germany\ncoord2 = (48.8566, 2.3522)   # Paris, France\n\n# Calculate the distance between the two coordinates in kilometers\ndistance_km = geodist(coord1, coord2, metric='km')\nprint(f\"Distance between Berlin and Paris: {distance_km} kilometers\")\n</code></pre>","path":["Getting Started with Geodistpy – Installation & Quick Start"],"tags":[]},{"location":"getting-started/#beyond-distance-bearing-destination-and-spatial-queries","level":2,"title":"Beyond Distance: Bearing, Destination, and Spatial Queries","text":"<p><code>geodistpy</code> goes beyond simple distance calculations. Here are a few more things you can do right away:</p> <pre><code>from geodistpy import bearing, destination, midpoint, interpolate, point_in_radius, geodesic_knn\n\nberlin = (52.5200, 13.4050)\nparis  = (48.8566, 2.3522)\n\n# Bearing: initial direction from Berlin to Paris\nprint(f\"Bearing: {bearing(berlin, paris):.2f}°\")\n\n# Destination: where do you end up travelling 500 km east from Berlin?\nprint(f\"Destination: {destination(berlin, 90.0, 500, metric='km')}\")\n\n# Midpoint along the geodesic\nprint(f\"Midpoint: {midpoint(berlin, paris)}\")\n\n# 3 evenly-spaced waypoints between Berlin and Paris\nprint(f\"Waypoints: {interpolate(berlin, paris, n_points=3)}\")\n\n# Which of these cities are within 1000 km of Berlin?\ncities = [(48.8566, 2.3522), (51.5074, -0.1278), (40.7128, -74.006)]\nidx, dists = point_in_radius(berlin, cities, 1000, metric='km')\nprint(f\"Within 1000 km: {idx}\")\n\n# 2 nearest cities to Berlin\nidx, dists = geodesic_knn(berlin, cities, k=2, metric='km')\nprint(f\"2 nearest: {idx}, distances: {dists.round(1)} km\")\n</code></pre> <p>For full API details, see the API Reference.</p>","path":["Getting Started with Geodistpy – Installation & Quick Start"],"tags":[]},{"location":"interpolation/","level":1,"title":"Geodesic Interpolation &amp; Midpoints","text":"<p>This guide covers generating points along a geodesic path — essential for route visualization, path rendering on maps, and spatial analysis.</p>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#why-geodesic-interpolation","level":2,"title":"Why Geodesic Interpolation?","text":"<p>When you draw a \"straight line\" between two points on a map, the actual shortest path on the Earth (the geodesic) curves. Simply interpolating latitude and longitude linearly produces incorrect paths, especially over long distances. Geodesic interpolation ensures waypoints lie on the true shortest path across the WGS-84 ellipsoid.</p> <p>Common use cases:</p> <ul> <li>Route visualization: Draw smooth geodesic arcs on maps</li> <li>Flight path rendering: Accurate great-circle routes for aviation</li> <li>Cable/pipeline routing: Plan paths along the Earth's surface</li> <li>Animation: Smooth movement between geographic coordinates</li> <li>Spatial sampling: Sample points at regular intervals along a path</li> </ul>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#midpoint","level":2,"title":"Midpoint","text":"<p>The <code>midpoint()</code> function returns the geographic point exactly halfway along the geodesic between two endpoints.</p>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#basic-usage","level":3,"title":"Basic Usage","text":"<pre><code>from geodistpy import midpoint, geodist\n\n# Midpoint between two equatorial points\nmid = midpoint((0.0, 0.0), (0.0, 10.0))\nprint(f\"Midpoint: ({mid[0]:.4f}, {mid[1]:.4f})\")\n# → (0.0000, 5.0000)\n\n# Midpoint between Berlin and Paris\nmid = midpoint((52.5200, 13.4050), (48.8566, 2.3522))\nprint(f\"Midpoint: ({mid[0]:.4f}, {mid[1]:.4f})\")\n</code></pre>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#verifying-the-midpoint","level":3,"title":"Verifying the Midpoint","text":"<p>The midpoint should be equidistant from both endpoints:</p> <pre><code>from geodistpy import midpoint, geodist\n\nA = (52.5200, 13.4050)  # Berlin\nB = (48.8566, 2.3522)   # Paris\n\nmid = midpoint(A, B)\n\nd_A = geodist(A, mid, metric='km')\nd_B = geodist(mid, B, metric='km')\nd_total = geodist(A, B, metric='km')\n\nprint(f\"A → mid:    {d_A:.2f} km\")\nprint(f\"mid → B:    {d_B:.2f} km\")\nprint(f\"A → B:      {d_total:.2f} km\")\nprint(f\"Sum:        {d_A + d_B:.2f} km\")\n# d_A ≈ d_B ≈ d_total / 2\n</code></pre>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#midpoint-is-symmetric","level":3,"title":"Midpoint is Symmetric","text":"<pre><code>from geodistpy import midpoint\n\nA = (52.5200, 13.4050)\nB = (48.8566, 2.3522)\n\nm1 = midpoint(A, B)\nm2 = midpoint(B, A)\n\nprint(f\"midpoint(A,B) = ({m1[0]:.6f}, {m1[1]:.6f})\")\nprint(f\"midpoint(B,A) = ({m2[0]:.6f}, {m2[1]:.6f})\")\n# These are identical\n</code></pre>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#interpolation-multiple-waypoints","level":2,"title":"Interpolation (Multiple Waypoints)","text":"<p>The <code>interpolate()</code> function generates N evenly-spaced interior waypoints that divide a geodesic into N+1 equal segments. The endpoints are not included in the output.</p>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#basic-usage_1","level":3,"title":"Basic Usage","text":"<pre><code>from geodistpy import interpolate\n\n# Single midpoint (same as midpoint())\npts = interpolate((0.0, 0.0), (0.0, 10.0), n_points=1)\nprint(pts)  # [(0.0, 5.0)]\n\n# Four interior waypoints → 5 equal segments\npts = interpolate((0.0, 0.0), (0.0, 10.0), n_points=4)\nfor i, p in enumerate(pts, 1):\n    print(f\"  Waypoint {i}: ({p[0]:.4f}, {p[1]:.4f})\")\n# → ~2°, ~4°, ~6°, ~8° longitude\n</code></pre>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#understanding-the-output","level":3,"title":"Understanding the Output","text":"<p>For <code>n_points=N</code>, the geodesic is divided into N+1 segments:</p> <pre><code>A ----●----●----●----●---- B     (n_points=4)\n     wp1  wp2  wp3  wp4\n\nSegments:  A→wp1, wp1→wp2, wp2→wp3, wp3→wp4, wp4→B\n           (all approximately equal length)\n</code></pre> <p>The endpoints A and B are not in the returned list. To get the complete path including endpoints:</p> <pre><code>from geodistpy import interpolate\n\nA = (52.5200, 13.4050)\nB = (48.8566, 2.3522)\n\nwaypoints = interpolate(A, B, n_points=4)\nfull_path = [A] + waypoints + [B]\n\nfor i, p in enumerate(full_path):\n    print(f\"  Point {i}: ({p[0]:.4f}, {p[1]:.4f})\")\n</code></pre>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#verifying-equal-spacing","level":3,"title":"Verifying Equal Spacing","text":"<pre><code>from geodistpy import interpolate, geodist\n\nA = (52.5200, 13.4050)  # Berlin\nB = (48.8566, 2.3522)   # Paris\n\nwaypoints = interpolate(A, B, n_points=4)\nfull_path = [A] + waypoints + [B]\n\ntotal = geodist(A, B, metric='km')\nprint(f\"Total distance: {total:.2f} km\")\nprint(f\"Expected segment: {total / 5:.2f} km\\n\")\n\nfor i in range(len(full_path) - 1):\n    d = geodist(full_path[i], full_path[i + 1], metric='km')\n    print(f\"  Segment {i}→{i+1}: {d:.2f} km\")\n</code></pre>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#real-world-examples","level":2,"title":"Real-World Examples","text":"","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#flight-path-rendering","level":3,"title":"Flight Path Rendering","text":"<p>Generate a smooth geodesic arc for display on a map:</p> <pre><code>from geodistpy import interpolate\n\n# New York → London flight path\nnyc = (40.7128, -74.0060)\nlondon = (51.5074, -0.1278)\n\n# 50 waypoints for a smooth curve\npath = interpolate(nyc, london, n_points=50)\nfull_path = [nyc] + path + [london]\n\n# full_path now contains 52 (lat, lon) tuples\n# ready for plotting on a map library like Folium, Plotly, or Matplotlib\nprint(f\"Path has {len(full_path)} points\")\nfor p in full_path[:5]:\n    print(f\"  ({p[0]:.4f}, {p[1]:.4f})\")\nprint(f\"  ...\")\n</code></pre>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#sampling-at-fixed-intervals","level":3,"title":"Sampling at Fixed Intervals","text":"<p>Instead of a fixed number of points, you can compute the number of points for a desired spacing:</p> <pre><code>from geodistpy import interpolate, geodist\n\nA = (40.7128, -74.0060)  # New York\nB = (51.5074, -0.1278)   # London\n\ntotal_km = geodist(A, B, metric='km')\ndesired_spacing_km = 100  # one point every 100 km\n\nn = max(1, int(total_km / desired_spacing_km) - 1)\nwaypoints = interpolate(A, B, n_points=n)\n\nprint(f\"Total distance: {total_km:.0f} km\")\nprint(f\"Generated {n} waypoints (~{total_km / (n + 1):.0f} km apart)\")\n</code></pre>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#chaining-multiple-segments","level":3,"title":"Chaining Multiple Segments","text":"<p>For a multi-leg route, interpolate each segment separately:</p> <pre><code>from geodistpy import interpolate\n\n# Multi-city route: Berlin → Paris → London\nlegs = [\n    ((52.5200, 13.4050), (48.8566, 2.3522)),   # Berlin → Paris\n    ((48.8566, 2.3522), (51.5074, -0.1278)),    # Paris → London\n]\n\nfull_route = []\nfor start, end in legs:\n    if full_route:\n        full_route.pop()  # avoid duplicate at junction\n    segment = [start] + interpolate(start, end, n_points=10) + [end]\n    full_route.extend(segment)\n\nprint(f\"Route has {len(full_route)} points across {len(legs)} legs\")\n</code></pre>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#how-it-works","level":2,"title":"How It Works","text":"<p>The interpolation algorithm uses two steps:</p> <ol> <li>Vincenty inverse: Compute the total geodesic distance <code>s</code> and forward azimuth <code>α₁</code> from point1 to point2.</li> <li>Vincenty direct (repeated): For each waypoint <code>i</code> in <code>[1, ..., N]</code>, compute the point at distance <code>s × i / (N+1)</code> from point1 along azimuth <code>α₁</code>.</li> </ol> <p>This approach produces points that lie exactly on the geodesic between the two endpoints, not on a great-circle approximation.</p> <p>Why not spherical interpolation?</p> <p>Spherical (SLERP) interpolation assumes a perfect sphere and can accumulate errors of up to ~21 km over intercontinental distances. Geodistpy's ellipsoidal interpolation uses the WGS-84 ellipsoid for maximum accuracy.</p>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#using-different-ellipsoids","level":2,"title":"Using Different Ellipsoids","text":"<p>Both <code>interpolate()</code> and <code>midpoint()</code> accept an optional <code>ellipsoid</code> parameter. By default, WGS-84 is used. You can choose from six built-in ellipsoids or pass a custom <code>(a, f)</code> tuple:</p> <pre><code>from geodistpy import midpoint, interpolate, ELLIPSOIDS\n\nberlin = (52.5200, 13.4050)\nparis  = (48.8566, 2.3522)\n\n# Midpoint on the GRS-80 ellipsoid\nmid = midpoint(berlin, paris, ellipsoid='GRS-80')\nprint(f\"GRS-80 midpoint: ({mid[0]:.6f}, {mid[1]:.6f})\")\n\n# Interpolation on the Intl 1924 ellipsoid\npts = interpolate(berlin, paris, n_points=3, ellipsoid='Intl 1924')\nfor i, p in enumerate(pts, 1):\n    print(f\"  Waypoint {i}: ({p[0]:.4f}, {p[1]:.4f})\")\n\n# Custom ellipsoid\nmid = midpoint(berlin, paris, ellipsoid=(6378137.0, 1/298.257222101))\nprint(f\"Custom midpoint: ({mid[0]:.6f}, {mid[1]:.6f})\")\n\n# See all available ellipsoids\nprint(ELLIPSOIDS.keys())\n# dict_keys(['WGS-84', 'GRS-80', 'Airy (1830)', 'Intl 1924', 'Clarke (1880)', 'GRS-67'])\n</code></pre> <p>Supported named ellipsoids: WGS-84 (default), GRS-80, Airy (1830), Intl 1924, Clarke (1880), GRS-67.</p>","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"interpolation/#edge-cases","level":2,"title":"Edge Cases","text":"Scenario Behavior Coincident points Returns N copies of the input point Very short distance Works correctly down to millimeter scale Near-antipodal points Falls back to GeographicLib for convergence Points on the equator Longitude interpolation is nearly linear Pole-crossing paths Handled correctly by Vincenty direct","path":["Geodesic Interpolation & Midpoints – Waypoints Along the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/","level":1,"title":"Spatial Queries: k-NN &amp; Point-in-Radius","text":"<p>This guide covers two spatial query operations that use exact geodesic (Vincenty) distances on the WGS-84 ellipsoid:</p> <ul> <li><code>geodesic_knn</code>: Find the k closest points to a query location</li> <li><code>point_in_radius</code>: Find all points within a given distance of a centre</li> </ul> <p>These fill an important gap: popular tools like scikit-learn's <code>BallTree</code> only support the haversine metric (spherical approximation), which can introduce errors of up to ~0.3% compared to true ellipsoidal distances.</p>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#k-nearest-neighbours-geodesic_knn","level":2,"title":"k-Nearest Neighbours (geodesic_knn)","text":"","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#why-geodesic-k-nn","level":3,"title":"Why Geodesic k-NN?","text":"<p>Standard k-NN implementations use Euclidean distance or haversine (spherical) approximations. On the WGS-84 ellipsoid, these can produce incorrect nearest-neighbour rankings, especially for:</p> <ul> <li>Points near the poles (where longitude lines converge)</li> <li>Long-distance queries (where ellipsoidal effects are significant)</li> <li>High-precision applications (logistics, surveying, telecommunications)</li> </ul> <p>Geodistpy's <code>geodesic_knn</code> uses Vincenty's inverse formula for every distance computation, ensuring sub-millimetre accuracy in the distance ranking.</p>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#basic-usage","level":3,"title":"Basic Usage","text":"<pre><code>from geodistpy import geodesic_knn\n\n# Candidate cities\ncities = [\n    (48.8566, 2.3522),    # 0: Paris\n    (40.7128, -74.0060),  # 1: New York\n    (51.5074, -0.1278),   # 2: London\n    (41.9028, 12.4964),   # 3: Rome\n    (59.3293, 18.0686),   # 4: Stockholm\n]\n\n# Find the 3 nearest cities to Berlin\nquery = (52.5200, 13.4050)\nidx, dists = geodesic_knn(query, cities, k=3, metric='km')\n\nprint(\"3 nearest cities to Berlin:\")\nnames = ['Paris', 'New York', 'London', 'Rome', 'Stockholm']\nfor i, (ci, d) in enumerate(zip(idx, dists)):\n    print(f\"  {i+1}. {names[ci]:&gt;10} — {d:.1f} km\")\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#understanding-the-output","level":3,"title":"Understanding the Output","text":"<p><code>geodesic_knn</code> returns a tuple of two NumPy arrays:</p> <ul> <li><code>indices</code>: Shape <code>(k,)</code> — indices into the <code>candidates</code> array, ordered nearest-first</li> <li><code>distances</code>: Shape <code>(k,)</code> — corresponding distances in the specified metric</li> </ul> <pre><code>idx, dists = geodesic_knn(query, candidates, k=3, metric='km')\n\n# idx[0] is the index of the nearest candidate\n# dists[0] is the distance to the nearest candidate\n# idx[1] is the second nearest, etc.\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#different-metrics","level":3,"title":"Different Metrics","text":"<pre><code>from geodistpy import geodesic_knn\n\nquery = (52.5200, 13.4050)\ncities = [(48.8566, 2.3522), (51.5074, -0.1278)]\n\n# Same query, different units\n_, d_m  = geodesic_knn(query, cities, k=1, metric='meter')\n_, d_km = geodesic_knn(query, cities, k=1, metric='km')\n_, d_mi = geodesic_knn(query, cities, k=1, metric='mile')\n_, d_nm = geodesic_knn(query, cities, k=1, metric='nmi')\n\nprint(f\"Nearest: {d_m[0]:.0f} m = {d_km[0]:.1f} km = {d_mi[0]:.1f} mi = {d_nm[0]:.1f} nmi\")\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#error-handling","level":3,"title":"Error Handling","text":"<pre><code>from geodistpy import geodesic_knn\n\n# k must be ≥ 1\ngeodesic_knn((0, 0), [(1, 1)], k=0)  # → ValueError\n\n# k must not exceed number of candidates\ngeodesic_knn((0, 0), [(1, 1)], k=5)  # → ValueError\n\n# Invalid coordinates\ngeodesic_knn((95, 0), [(1, 1)], k=1)  # → ValueError (lat &gt; 90)\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#point-in-radius","level":2,"title":"Point-in-Radius","text":"","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#why-point-in-radius","level":3,"title":"Why Point-in-Radius?","text":"<p>The <code>point_in_radius</code> function finds all candidate points within a specified geodesic distance of a centre point. This is the fundamental operation behind:</p> <ul> <li>Geofencing: Trigger actions when devices enter/leave a zone</li> <li>Store locators: \"Find stores within 10 km of me\"</li> <li>Proximity alerts: Warn when approaching a restricted area</li> <li>Service coverage: Determine which users are within coverage radius</li> <li>Spatial filtering: Pre-filter candidates before detailed analysis</li> </ul>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#basic-usage_1","level":3,"title":"Basic Usage","text":"<pre><code>from geodistpy import point_in_radius\n\n# Candidate locations\nlocations = [\n    (48.8566, 2.3522),    # 0: Paris      (~880 km from Berlin)\n    (40.7128, -74.0060),  # 1: New York   (~6400 km from Berlin)\n    (51.5074, -0.1278),   # 2: London     (~930 km from Berlin)\n    (41.9028, 12.4964),   # 3: Rome       (~1180 km from Berlin)\n    (59.3293, 18.0686),   # 4: Stockholm  (~810 km from Berlin)\n]\n\n# Find locations within 1000 km of Berlin\ncentre = (52.5200, 13.4050)\nidx, dists = point_in_radius(centre, locations, 1000, metric='km')\n\nnames = ['Paris', 'New York', 'London', 'Rome', 'Stockholm']\nprint(f\"Cities within 1000 km of Berlin:\")\nfor i, (ci, d) in enumerate(zip(idx, dists)):\n    print(f\"  {names[ci]:&gt;10} — {d:.1f} km\")\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#understanding-the-output_1","level":3,"title":"Understanding the Output","text":"<p><code>point_in_radius</code> returns a tuple of two NumPy arrays:</p> <ul> <li><code>indices</code>: Indices into <code>candidates</code> of points within the radius</li> <li><code>distances</code>: Corresponding distances to each point within the radius</li> </ul> <pre><code>idx, dists = point_in_radius(centre, candidates, radius, metric='km')\n\n# len(idx) is the number of points found\n# idx contains the original indices into candidates\n# dists[i] is the distance to candidates[idx[i]]\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#boundary-behaviour","level":3,"title":"Boundary Behaviour","text":"<p>Points exactly on the boundary (distance = radius) are included:</p> <pre><code>from geodistpy import point_in_radius, geodist\n\ncentre = (0.0, 0.0)\npt = (0.0, 1.0)\n\nexact_dist = geodist(centre, pt, metric='km')\nidx, _ = point_in_radius(centre, [pt], exact_dist, metric='km')\nprint(f\"Included: {0 in idx}\")  # True (boundary is inclusive)\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#empty-results","level":3,"title":"Empty Results","text":"<p>When no points fall within the radius, empty arrays are returned:</p> <pre><code>from geodistpy import point_in_radius\n\nidx, dists = point_in_radius((0, 0), [(48.8566, 2.3522)], 10, metric='km')\nprint(f\"Found: {len(idx)} points\")  # 0\nprint(f\"idx: {idx}\")                # []\nprint(f\"dists: {dists}\")            # []\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#real-world-examples","level":2,"title":"Real-World Examples","text":"","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#store-locator","level":3,"title":"Store Locator","text":"<pre><code>from geodistpy import point_in_radius\n\n# Store coordinates (lat, lon)\nstores = [\n    (48.8534, 2.3488),   # Store A — central Paris\n    (48.8738, 2.2950),   # Store B — near Eiffel Tower\n    (48.8606, 2.3376),   # Store C — Louvre area\n    (48.8156, 2.3631),   # Store D — south Paris\n    (49.0097, 2.5479),   # Store E — CDG airport area\n]\n\n# User location\nuser = (48.8566, 2.3522)  # near Notre-Dame\n\n# Find stores within 3 km\nidx, dists = point_in_radius(user, stores, 3, metric='km')\n\nprint(f\"Stores within 3 km:\")\nfor ci, d in zip(idx, dists):\n    print(f\"  Store {chr(65 + ci)} — {d * 1000:.0f} m away\")\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#geofencing-alert-system","level":3,"title":"Geofencing Alert System","text":"<pre><code>from geodistpy import point_in_radius\n\n# Restricted zones (centre points)\nrestricted_zones = [\n    (51.4775, -0.4614),  # Heathrow Airport\n    (51.1537, -0.1821),  # Gatwick Airport\n]\nzone_radius_km = 5  # 5 km exclusion zone\n\n# Check if a drone position violates any zone\ndrone_pos = (51.4700, -0.4500)\n\nfor i, zone in enumerate(restricted_zones):\n    idx, dists = point_in_radius(zone, [drone_pos], zone_radius_km, metric='km')\n    if len(idx) &gt; 0:\n        print(f\"⚠️  ALERT: Within {dists[0]:.2f} km of restricted zone {i}\")\n    else:\n        print(f\"✅ Clear of restricted zone {i}\")\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#combining-k-nn-with-point-in-radius","level":3,"title":"Combining k-NN with Point-in-Radius","text":"<p>A common pattern: first filter by radius, then rank the results:</p> <pre><code>from geodistpy import point_in_radius, geodesic_knn\nimport numpy as np\n\n# Many candidate locations\ncandidates = [\n    (48.8566, 2.3522),    # Paris\n    (40.7128, -74.0060),  # New York\n    (51.5074, -0.1278),   # London\n    (41.9028, 12.4964),   # Rome\n    (59.3293, 18.0686),   # Stockholm\n    (50.0755, 14.4378),   # Prague\n    (52.2297, 21.0122),   # Warsaw\n    (47.4979, 19.0402),   # Budapest\n]\n\nquery = (52.5200, 13.4050)  # Berlin\n\n# Step 1: Filter to within 1500 km\nidx_in_range, _ = point_in_radius(query, candidates, 1500, metric='km')\nnearby = [candidates[i] for i in idx_in_range]\n\n# Step 2: Find the 3 nearest among those\nif len(nearby) &gt;= 3:\n    knn_idx, knn_dists = geodesic_knn(query, nearby, k=3, metric='km')\n    print(\"Top 3 nearest within 1500 km:\")\n    for ki, kd in zip(knn_idx, knn_dists):\n        original_idx = idx_in_range[ki]\n        print(f\"  Index {original_idx}: {kd:.1f} km\")\n</code></pre>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#haversine-vs-vincenty-why-it-matters","level":2,"title":"Haversine vs Vincenty: Why It Matters","text":"Aspect Haversine (spherical) Vincenty (ellipsoidal) Earth model Perfect sphere (R=6371 km) WGS-84 ellipsoid Mean error ~0.3% (~3 km per 1000 km) ~0.000001% (~9 µm) Max error ~0.5% at equator Sub-millimetre Ranking errors Possible for close candidates None Speed (geodistpy) ~0.3 µs/call ~0.5 µs/call <p>For most k-NN and radius queries, the ranking is what matters. In cases where two candidates are close in distance, haversine's ~0.3% error can swap their order, returning the wrong \"nearest\" point. Vincenty eliminates this risk entirely.</p>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#performance-considerations","level":2,"title":"Performance Considerations","text":"Operation 10 candidates 100 candidates 1,000 candidates <code>geodesic_knn</code> ~5 µs ~50 µs ~500 µs <code>point_in_radius</code> ~5 µs ~50 µs ~500 µs <p>Both functions compute distances sequentially (one Vincenty call per candidate). For very large candidate sets (&gt;100,000 points), consider:</p> <ol> <li>Pre-filtering with a bounding box on lat/lon before calling these functions</li> <li>Using <code>geodist_matrix</code> for batch computation when you need all pairwise distances</li> </ol>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#using-different-ellipsoids","level":2,"title":"Using Different Ellipsoids","text":"<p>Both <code>geodesic_knn()</code> and <code>point_in_radius()</code> accept an optional <code>ellipsoid</code> parameter. By default, WGS-84 is used. You can choose from six built-in ellipsoids or pass a custom <code>(a, f)</code> tuple:</p> <pre><code>from geodistpy import geodesic_knn, point_in_radius, ELLIPSOIDS\n\nquery = (52.5200, 13.4050)  # Berlin\ncities = [\n    (48.8566, 2.3522),    # Paris\n    (51.5074, -0.1278),   # London\n    (41.9028, 12.4964),   # Rome\n]\n\n# k-NN on the GRS-80 ellipsoid\nidx, dists = geodesic_knn(query, cities, k=2, metric='km', ellipsoid='GRS-80')\nprint(f\"GRS-80 nearest: indices {idx}, distances {dists.round(1)} km\")\n\n# Point-in-radius on the Clarke 1880 ellipsoid\nidx, dists = point_in_radius(query, cities, 1000, metric='km', ellipsoid='Clarke (1880)')\nprint(f\"Clarke within 1000 km: indices {idx}\")\n\n# Custom ellipsoid\nidx, dists = geodesic_knn(query, cities, k=1, metric='km', ellipsoid=(6378160.0, 1/298.25))\nprint(f\"Custom nearest: index {idx[0]}, distance {dists[0]:.1f} km\")\n\n# See all available ellipsoids\nprint(ELLIPSOIDS.keys())\n# dict_keys(['WGS-84', 'GRS-80', 'Airy (1830)', 'Intl 1924', 'Clarke (1880)', 'GRS-67'])\n</code></pre> <p>Supported named ellipsoids: WGS-84 (default), GRS-80, Airy (1830), Intl 1924, Clarke (1880), GRS-67.</p>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]},{"location":"spatial-queries/#edge-cases","level":2,"title":"Edge Cases","text":"Scenario Behavior k = n (all candidates) Returns all candidates sorted by distance Coincident query and candidate Distance = 0, included in results Near-antipodal points GeographicLib fallback ensures correct distance Points at the poles Handled correctly Empty radius result Returns empty arrays <code>(array([]), array([]))</code>","path":["Spatial Queries – k-NN & Point-in-Radius on the WGS-84 Ellipsoid"],"tags":[]}]}