{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Project Documentation","text":"<p>Welcome to the documentation for the <code>geodistpy</code> project. This documentation serves as a comprehensive guide to using and understanding the <code>geodistpy</code> Python package, which is designed for geospatial calculations involving distances between geographical coordinates.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation is organized to help you quickly find the information you need. Here are the main sections:</p> <ol> <li>Getting Started</li> <li>Explanation</li> <li>API Reference</li> </ol>"},{"location":"#introduction","title":"Introduction","text":"<p>The <code>geodistpy</code> package is a versatile library for geospatial calculations, offering various distance metrics and functionalities. It is built on the principles of geodesy and uses the WGS 84 coordinate system, making it suitable for a wide range of applications, from GPS tracking to geographical analysis.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Blazing fast: ~0.4 \u00b5s per distance call \u2014 up to 171x faster than Geopy, 109x faster than Geographiclib</li> <li>Parallel matrix computation: Up to 1,230x faster than Geopy for pairwise distance matrices using Numba parallel execution</li> <li>Sub-millimeter accuracy: Vincenty's inverse formula with mean error of just 9 \u00b5m vs Geographiclib reference</li> <li>Improved Great Circle: Andoyer-Lambert flattening correction reduces spherical approximation error by 700x (from ~13 km to ~19 m)</li> <li>Edge case handling: Antipodal points, poles, date line crossings, and very short distances all handled correctly</li> </ul>"},{"location":"#license","title":"License","text":"<p>The geodistpy project is licensed under the MIT License.</p>"},{"location":"api-reference/","title":"API References","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>geodistpy</code> project code.</p> <p>Computation of geospatial distances (WGS84).</p>"},{"location":"api-reference/#geodistpy.distance--computation-of-geospatial-distances-wgs84","title":"Computation of Geospatial Distances (WGS84)","text":"<p>Coordinates are assumed to be in Latitude and Longitude (WGS 84). Accepting numpy arrays as input.</p> <p>The geospatial distance calculation is based on Vincenty's inverse method formula and accelerated with Numba (see <code>geodistpy.geodesic.geodesic_vincenty</code> and references).</p> <p>In a few cases (&lt;0.01%) Vincenty's inverse method can fail to converge, and a fallback option using the slower geographiclib solution is implemented.</p>"},{"location":"api-reference/#geodistpy.distance--functions-included","title":"Functions Included:","text":"<ul> <li><code>geodist</code>: returns a list of distances between points of two lists: <code>dist[i] = distance(XA[i], XB[i])</code></li> <li><code>geodist_matrix</code>: returns a distance matrix between all possible combinations   of pairwise distances (either between all points in one list or points between   two lists). <code>dist[i,j] = distance(XA[i], XB[j])</code> or <code>distance(X[i], X[j])</code></li> </ul> <p>This implementation provides a fast computation of geo-spatial distances in comparison to alternative methods for computing geodesic distance (tested: geopy and GeographicLib, see <code>tests.test_geodist</code> for test functions).</p>"},{"location":"api-reference/#geodistpy.distance--references","title":"References:","text":"<ul> <li>Vincenty's Formulae</li> <li>GeographicLib</li> <li>Karney, Charles F. F. (January 2013). \"Algorithms for geodesics\".   Journal of Geodesy. 87 (1): 43-55.   arXiv:1109.4448.   doi:10.1007/s00190-012-0578-z.</li> </ul>"},{"location":"api-reference/#geodistpy.distance.geodist","title":"<code>geodist(coords1, coords2, metric='meter')</code>","text":"<p>Return distances between two coordinates or two lists of coordinates.</p> <p>Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.</p> <p>For distances between all pair combinations, see geo_pdist and geo_cdist.</p> <p>Parameters:</p> Name Type Description Default <code>coords1</code> <code>array - like</code> <p>The first set of coordinates in the format (latitude, longitude) or an array with shape (n_points1, 2) for multiple points.</p> required <code>coords2</code> <code>array - like</code> <p>The second set of coordinates in the format (latitude, longitude) or an array with shape (n_points2, 2) for multiple points. The shape of coords1 should match the shape of coords2.</p> required <code>metric</code> <code>str</code> <p>The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'. Default is 'meter'.</p> <code>'meter'</code> <p>Returns:</p> Type Description <p>float or ndarray: The distance(s) between points, with a length of n_points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If the input coordinates do not have the expected shape.</li> <li>If latitude values are not in the range [-90, 90].</li> <li>If longitude values are not in the range [-180, 180].</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geodist((52.5200, 13.4050), (48.8566, 2.3522), metric='km')\n878.389841013836\n</code></pre> <pre><code>&gt;&gt;&gt; coords1 = [(37.7749, -122.4194), (34.0522, -118.2437)]\n&gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n&gt;&gt;&gt; geodist(coords1, coords2, metric='mile')\narray([2449.92107243, 1745.82567572])\n</code></pre> <pre><code>&gt;&gt;&gt; geodist((37.7749, -122.4194), (37.7749, -122.4194))\n0.0\n</code></pre> Source code in <code>geodistpy/distance.py</code> <pre><code>def geodist(coords1, coords2, metric=\"meter\"):\n    \"\"\"\n    Return distances between two coordinates or two lists of coordinates.\n\n    Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.\n\n    For distances between all pair combinations, see geo_pdist and geo_cdist.\n\n    Parameters:\n        coords1 (array-like): The first set of coordinates in the format (latitude, longitude) or an array with shape (n_points1, 2) for multiple points.\n        coords2 (array-like): The second set of coordinates in the format (latitude, longitude) or an array with shape (n_points2, 2) for multiple points.\n            The shape of coords1 should match the shape of coords2.\n        metric (str, optional): The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'.\n            Default is 'meter'.\n\n    Returns:\n        float or ndarray: The distance(s) between points, with a length of n_points.\n\n    Raises:\n        ValueError:\n            - If the input coordinates do not have the expected shape.\n            - If latitude values are not in the range [-90, 90].\n            - If longitude values are not in the range [-180, 180].\n\n    Examples:\n        &gt;&gt;&gt; geodist((52.5200, 13.4050), (48.8566, 2.3522), metric='km')\n        878.389841013836\n\n        &gt;&gt;&gt; coords1 = [(37.7749, -122.4194), (34.0522, -118.2437)]\n        &gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n        &gt;&gt;&gt; geodist(coords1, coords2, metric='mile')\n        array([2449.92107243, 1745.82567572])\n\n        &gt;&gt;&gt; geodist((37.7749, -122.4194), (37.7749, -122.4194))\n        0.0\n    \"\"\"\n    coords1 = np.asarray(coords1)\n    coords2 = np.asarray(coords2)\n    assert coords1.shape == coords2.shape\n\n    conv_fac = _get_conv_factor(metric)\n\n    if np.size(coords1) == 2:\n        if coords1.shape[0] != 2 or coords2.shape[0] != 2:\n            raise ValueError(\n                \"coords1 and coords2 must have two dimensions: Latitude, Longitude\"\n            )\n        if (abs(coords1[0]) &gt; 90).any() or (abs(coords2[0]) &gt; 90).any():\n            raise ValueError(\"Latitude values must be in the range [-90, 90]\")\n        if (abs(coords1[1]) &gt; 180).any() or (abs(coords2[1]) &gt; 180).any():\n            raise ValueError(\"Longitude values must be in the range [-180, 180]\")\n        return geodesic_vincenty(coords1, coords2) * conv_fac\n\n    if coords1.shape[1] != 2:\n        raise ValueError(\n            \"coords1 and coords2 must have two dimensions: Latitude, Longitude\"\n        )\n    if (abs(coords1[:, 0]) &gt; 90).any() or (abs(coords2[:, 0]) &gt; 90).any():\n        raise ValueError(\"Latitude values must be in the range [-90, 90]\")\n    if (abs(coords1[:, 1]) &gt; 180).any() or (abs(coords2[:, 1]) &gt; 180).any():\n        raise ValueError(\"Longitude values must be in the range [-180, 180]\")\n    n_points = len(coords1)\n    dist = np.asarray(\n        [geodesic_vincenty(coords1[i], coords2[i]) for i in range(n_points)]\n    )\n    return dist * conv_fac\n</code></pre>"},{"location":"api-reference/#geodistpy.distance.geodist_matrix","title":"<code>geodist_matrix(coords1, coords2=None, metric='meter')</code>","text":"<p>Compute distance between each pair of possible combinations.</p> <p>If coords2 is None, compute distance between all possible pair combinations in coords1. dist[i, j] = distance(XA[i], XB[j])</p> <p>If coords2 is given, compute distance between each possible pair of the two collections of inputs: dist[i, j] = distance(X[i], X[j])</p> <p>Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.</p> <p>Parameters:</p> Name Type Description Default <code>coords1</code> <code>list of tuples</code> <p>List of coordinates in the format [(lat, long)] or an array with shape (n_points1, 2).</p> required <code>coords2</code> <code>list of tuples</code> <p>List of coordinates in the format [(lat, long)] or an array with shape (n_points2, 2). If coords2 is not None, coords1.shape must match coords2.shape. Default is None.</p> <code>None</code> <code>metric</code> <code>str</code> <p>The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'. Default is 'meter'.</p> <code>'meter'</code> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>A distance matrix is returned. - If only coords1 is given, for each i and j, the metric dist(u=XA[i], v=XA[j]) is computed. - If coords2 is not None, for each i and j, the metric dist(u=XA[i], v=XB[j]) is computed and stored in the ij-th entry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If the input coordinates do not have the expected shape.</li> <li>If latitude values are not in the range [-90, 90].</li> <li>If longitude values are not in the range [-180, 180].</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; coords1 = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n&gt;&gt;&gt; geodist_matrix(coords1, metric='km')\narray([[   0.        ,  878.38984101, 8786.58652276],\n       [ 878.38984101,    0.        , 9525.03650888],\n       [8786.58652276, 9525.03650888,    0.        ]])\n</code></pre> <pre><code>&gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n&gt;&gt;&gt; geodist_matrix(coords1, coords2, metric='mile')\narray([[ 3060.81391478, 2437.78157493],\n       [ 4290.62813902, 1745.82567572],\n       [ 2449.92107243, 1746.57308007]])\n</code></pre> Source code in <code>geodistpy/distance.py</code> <pre><code>def geodist_matrix(coords1, coords2=None, metric=\"meter\"):\n    \"\"\"\n    Compute distance between each pair of possible combinations.\n\n    If coords2 is None, compute distance between all possible pair combinations in coords1.\n    dist[i, j] = distance(XA[i], XB[j])\n\n    If coords2 is given, compute distance between each possible pair of the two collections\n    of inputs: dist[i, j] = distance(X[i], X[j])\n\n    Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.\n\n    Parameters:\n        coords1 (list of tuples): List of coordinates in the format [(lat, long)] or an array with shape (n_points1, 2).\n        coords2 (list of tuples, optional): List of coordinates in the format [(lat, long)] or an array with shape (n_points2, 2).\n            If coords2 is not None, coords1.shape must match coords2.shape.\n            Default is None.\n        metric (str, optional): The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'.\n            Default is 'meter'.\n\n    Returns:\n        ndarray: A distance matrix is returned.\n            - If only coords1 is given, for each i and j, the metric dist(u=XA[i], v=XA[j]) is computed.\n            - If coords2 is not None, for each i and j, the metric dist(u=XA[i], v=XB[j]) is computed and stored in the ij-th entry.\n\n    Raises:\n        ValueError:\n            - If the input coordinates do not have the expected shape.\n            - If latitude values are not in the range [-90, 90].\n            - If longitude values are not in the range [-180, 180].\n\n    Examples:\n        &gt;&gt;&gt; coords1 = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n        &gt;&gt;&gt; geodist_matrix(coords1, metric='km')\n        array([[   0.        ,  878.38984101, 8786.58652276],\n               [ 878.38984101,    0.        , 9525.03650888],\n               [8786.58652276, 9525.03650888,    0.        ]])\n\n        &gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n        &gt;&gt;&gt; geodist_matrix(coords1, coords2, metric='mile')\n        array([[ 3060.81391478, 2437.78157493],\n               [ 4290.62813902, 1745.82567572],\n               [ 2449.92107243, 1746.57308007]])\n    \"\"\"\n    conv_fac = _get_conv_factor(metric)\n\n    coords1 = np.asarray(coords1)\n    if coords1.shape[1] != 2:\n        raise ValueError(\n            \"coords1 and coords2 must have two dimensions: Latitude, Longitude\"\n        )\n    if (abs(coords1[:, 0]) &gt; 90).any() or (abs(coords1[:, 1]) &gt; 180).any():\n        raise ValueError(\n            \"Latitude values must be in the range [-90, 90] and Longitude values must be in the range [-180, 180].\"\n        )\n\n    if coords2 is None:\n        dist = _vincenty_pdist(np.ascontiguousarray(coords1, dtype=np.float64))\n        dist = _apply_fallback(dist, coords1)\n    else:\n        coords2 = np.asarray(coords2)\n\n        # If two lists of coordinates are given\n        assert coords1.shape == coords2.shape\n        if (abs(coords2[:, 0]) &gt; 90).any() or (abs(coords2[:, 1]) &gt; 180).any():\n            raise ValueError(\n                \"Latitude values must be in the range [-90, 90] and Longitude values must be in the range [-180, 180].\"\n            )\n        dist = _vincenty_cdist(\n            np.ascontiguousarray(coords1, dtype=np.float64),\n            np.ascontiguousarray(coords2, dtype=np.float64),\n        )\n        dist = _apply_fallback(dist, coords1, coords2)\n    return dist * conv_fac\n</code></pre>"},{"location":"api-reference/#geodistpy.distance.greatcircle","title":"<code>greatcircle(coords1, coords2, metric='meter')</code>","text":"<p>Calculate the distance between two sets of coordinates using the Great Circle approximation.</p> <p>Parameters:</p> Name Type Description Default <code>coords1</code> <code>array - like</code> <p>The first set of coordinates in the format (latitude, longitude) or an array with shape (n_points1, 2) for multiple points.</p> required <code>coords2</code> <code>array - like</code> <p>The second set of coordinates in the format (latitude, longitude) or an array with shape (n_points2, 2) for multiple points. The shape of coords1 should match the shape of coords2.</p> required <code>metric</code> <code>str</code> <p>The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'. Default is 'meter'.</p> <code>'meter'</code> <p>Returns:</p> Type Description <p>float or ndarray: The distance(s) between the points. If multiple points are provided, an ndarray is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If the input coordinates do not have the expected shape.</li> <li>If latitude values are not in the range [-90, 90].</li> <li>If longitude values are not in the range [-180, 180].</li> </ul> Notes <p>The Great Circle formula assumes a spherical Earth and may not be completely accurate for very long distances or in regions with significant variation in the Earth's curvature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; greatcircle((52.5200, 13.4050), (48.8566, 2.3522), metric='km')\n878.389841013836\n</code></pre> <pre><code>&gt;&gt;&gt; coords1 = [(37.7749, -122.4194), (34.0522, -118.2437)]\n&gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n&gt;&gt;&gt; greatcircle(coords1, coords2, metric='mile')\narray([2449.92107243, 1745.82567572])\n</code></pre> <pre><code>&gt;&gt;&gt; greatcircle((37.7749, -122.4194), (37.7749, -122.4194))\n0.0\n</code></pre> Source code in <code>geodistpy/distance.py</code> <pre><code>def greatcircle(coords1, coords2, metric=\"meter\"):\n    \"\"\"Calculate the distance between two sets of coordinates using the Great Circle approximation.\n\n    Args:\n        coords1 (array-like): The first set of coordinates in the format (latitude, longitude) or an array with shape (n_points1, 2) for multiple points.\n        coords2 (array-like): The second set of coordinates in the format (latitude, longitude) or an array with shape (n_points2, 2) for multiple points.\n            The shape of coords1 should match the shape of coords2.\n        metric (str, optional): The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'.\n            Default is 'meter'.\n\n    Returns:\n        float or ndarray: The distance(s) between the points. If multiple points are provided, an ndarray is returned.\n\n    Raises:\n        ValueError:\n            - If the input coordinates do not have the expected shape.\n            - If latitude values are not in the range [-90, 90].\n            - If longitude values are not in the range [-180, 180].\n\n    Notes:\n        The Great Circle formula assumes a spherical Earth and may not be completely accurate\n        for very long distances or in regions with significant variation in the Earth's curvature.\n\n    Examples:\n        &gt;&gt;&gt; greatcircle((52.5200, 13.4050), (48.8566, 2.3522), metric='km')\n        878.389841013836\n\n        &gt;&gt;&gt; coords1 = [(37.7749, -122.4194), (34.0522, -118.2437)]\n        &gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n        &gt;&gt;&gt; greatcircle(coords1, coords2, metric='mile')\n        array([2449.92107243, 1745.82567572])\n\n        &gt;&gt;&gt; greatcircle((37.7749, -122.4194), (37.7749, -122.4194))\n        0.0\n    \"\"\"\n    coords1 = np.asarray(coords1)\n    coords2 = np.asarray(coords2)\n    assert coords1.shape == coords2.shape\n\n    conv_fac = _get_conv_factor(metric)\n\n    if np.size(coords1) == 2:\n        return great_circle_array(coords1, coords2) * conv_fac\n    if coords1.shape[1] != 2:\n        raise ValueError(\n            \"coords1 and coords2 must have two dimensions: Latitude, Longitude\"\n        )\n    if (abs(coords1[:, 0]) &gt; 90).any() or (abs(coords2[:, 0]) &gt; 90).any():\n        raise ValueError(\"Latitude values must be in the range [-90, 90]\")\n    if (abs(coords1[:, 1]) &gt; 180).any() or (abs(coords2[:, 1]) &gt; 180).any():\n        raise ValueError(\"Longitude values must be in the range [-180, 180]\")\n\n    dist = great_circle_array(coords1, coords2)\n    return dist * conv_fac\n</code></pre>"},{"location":"api-reference/#geodistpy.distance.greatcircle_matrix","title":"<code>greatcircle_matrix(coords1, coords2=None, metric='meter')</code>","text":"<p>Compute distance between each pair of possible combinations using spherical asymmetry (Great Circle approximation).</p> <p>If coords2 is None, compute distance between all possible pair combinations in coords1. dist[i, j] = distance(XA[i], XB[j])</p> <p>If coords2 is given, compute distance between each possible pair of the two collections of inputs: dist[i, j] = distance(X[i], X[j])</p> <p>Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.</p> <p>Parameters:</p> Name Type Description Default <code>coords1</code> <code>list of tuples</code> <p>List of coordinates in the format [(lat, long)] or an array with shape (n_points1, 2).</p> required <code>coords2</code> <code>list of tuples</code> <p>List of coordinates in the format [(lat, long)] or an array with shape (n_points2, 2). If coords2 is not None, coords1.shape must match coords2.shape. Default is None.</p> <code>None</code> <code>metric</code> <code>str</code> <p>The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'. Default is 'meter'.</p> <code>'meter'</code> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>A distance matrix is returned. - If only coords1 is given, for each i and j, the metric dist(u=XA[i], v=XA[j]) is computed. - If coords2 is not None, for each i and j, the metric dist(u=XA[i], v=XB[j]) is computed and stored in the ij-th entry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If the input coordinates do not have the expected shape.</li> <li>If latitude values are not in the range [-90, 90].</li> <li>If longitude values are not in the range [-180, 180].</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; coords1 = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n&gt;&gt;&gt; greatcircle_matrix(coords1, metric='km')\narray([[   0.        ,  878.38984101, 8786.58652276],\n       [ 878.38984101,    0.        , 9525.03650888],\n       [8786.58652276, 9525.03650888,    0.        ]])\n</code></pre> <pre><code>&gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n&gt;&gt;&gt; greatcircle_matrix(coords1, coords2, metric='mile')\narray([[ 3060.81391478, 2437.78157493],\n       [ 4290.62813902, 1745.82567572],\n       [ 2449.92107243, 1746.57308007]])\n</code></pre> Source code in <code>geodistpy/distance.py</code> <pre><code>def greatcircle_matrix(coords1, coords2=None, metric=\"meter\"):\n    \"\"\"\n    Compute distance between each pair of possible combinations\n    using spherical asymmetry (Great Circle approximation).\n\n    If coords2 is None, compute distance between all possible pair combinations in coords1.\n    dist[i, j] = distance(XA[i], XB[j])\n\n    If coords2 is given, compute distance between each possible pair of the two collections\n    of inputs: dist[i, j] = distance(X[i], X[j])\n\n    Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.\n\n    Parameters:\n        coords1 (list of tuples): List of coordinates in the format [(lat, long)] or an array with shape (n_points1, 2).\n        coords2 (list of tuples, optional): List of coordinates in the format [(lat, long)] or an array with shape (n_points2, 2).\n            If coords2 is not None, coords1.shape must match coords2.shape.\n            Default is None.\n        metric (str, optional): The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'.\n            Default is 'meter'.\n\n    Returns:\n        ndarray: A distance matrix is returned.\n            - If only coords1 is given, for each i and j, the metric dist(u=XA[i], v=XA[j]) is computed.\n            - If coords2 is not None, for each i and j, the metric dist(u=XA[i], v=XB[j]) is computed and stored in the ij-th entry.\n\n    Raises:\n        ValueError:\n            - If the input coordinates do not have the expected shape.\n            - If latitude values are not in the range [-90, 90].\n            - If longitude values are not in the range [-180, 180].\n\n    Examples:\n        &gt;&gt;&gt; coords1 = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n        &gt;&gt;&gt; greatcircle_matrix(coords1, metric='km')\n        array([[   0.        ,  878.38984101, 8786.58652276],\n               [ 878.38984101,    0.        , 9525.03650888],\n               [8786.58652276, 9525.03650888,    0.        ]])\n\n        &gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n        &gt;&gt;&gt; greatcircle_matrix(coords1, coords2, metric='mile')\n        array([[ 3060.81391478, 2437.78157493],\n               [ 4290.62813902, 1745.82567572],\n               [ 2449.92107243, 1746.57308007]])\n    \"\"\"\n    conv_fac = _get_conv_factor(metric)\n\n    coords1 = np.asarray(coords1)\n    if coords1.shape[1] != 2:\n        raise ValueError(\n            \"coords1 and coords2 must have two dimensions: Latitude, Longitude\"\n        )\n    if (abs(coords1[:, 0]) &gt; 90).any() or (abs(coords1[:, 1]) &gt; 180).any():\n        raise ValueError(\n            \"Latitude values must be in the range [-90, 90] and Longitude values must be in the range [-180, 180].\"\n        )\n\n    if coords2 is None:\n        # If only one list of coordinates is given:\n        dist = _great_circle_pdist(np.ascontiguousarray(coords1, dtype=np.float64))\n    else:\n        coords2 = np.asarray(coords2)\n        assert coords1.shape == coords2.shape\n\n        if (abs(coords2[:, 0]) &gt; 90).any() or (abs(coords2[:, 1]) &gt; 180).any():\n            raise ValueError(\n                \"Latitude values must be in the range [-90, 90] and Longitude values must be in the range [-180, 180].\"\n            )\n        dist = _great_circle_cdist(\n            np.ascontiguousarray(coords1, dtype=np.float64),\n            np.ascontiguousarray(coords2, dtype=np.float64),\n        )\n    return dist * conv_fac\n</code></pre>"},{"location":"explanation/","title":"Explanation","text":"<p>Geodistpy is a powerful Python library designed for lightning-fast geospatial distance computations. It uses Vincenty's inverse formula accelerated with Numba JIT compilation and parallel execution to achieve extreme performance, while maintaining sub-millimeter accuracy on the WGS84 ellipsoid.</p>"},{"location":"explanation/#speed-comparison","title":"Speed Comparison","text":"<pre><code># Import libraries\nfrom geopy.distance import geodesic as geodesic_geopy\nfrom geographiclib.geodesic import Geodesic as geodesic_gglib\nfrom geodistpy.geodesic import geodesic_vincenty\n\n# Define two coordinates\ncoord1 = (52.5200, 13.4050)  # Berlin\ncoord2 = (48.8566, 2.3522)   # Paris\n\n# Calculate distance with Geopy (based on Geographiclib)\ndistance_geopy = geodesic_geopy(coord1, coord2).meters\n\n# Calculate distance with Geographiclib\ndistance_gglib = geodesic_gglib.WGS84.Inverse(coord1[0], coord1[1], coord2[0], coord2[1])['s12']\n\n# Calculate distance with Geodistpy\ndistance_geodistpy = geodesic_vincenty(coord1, coord2)\n\n# Print the results\nprint(f\"Distance between Berlin and Paris:\")\nprint(f\"Geopy: {distance_geopy} meters\")\nprint(f\"Geographiclib: {distance_gglib} meters\")\nprint(f\"Geodistpy: {distance_geodistpy} meters\")\n</code></pre>"},{"location":"explanation/#single-pair-performance-10000-calls-best-of-3","title":"Single-Pair Performance (10,000 calls, best of 3)","text":"Library Total Time Per Call Geopy ~636 ms ~64 \u00b5s Geographiclib ~406 ms ~41 \u00b5s Geodistpy (Vincenty+Numba) ~3.7 ms ~0.4 \u00b5s <ul> <li>Geodistpy is ~171x faster than Geopy</li> <li>Geodistpy is ~109x faster than Geographiclib</li> </ul>"},{"location":"explanation/#pairwise-distance-matrix-nn","title":"Pairwise Distance Matrix (N\u00d7N)","text":"<p>For matrix computations, Geodistpy uses Numba-parallel loops instead of scipy callbacks, yielding massive speedups:</p> N points Unique Pairs Geopy Geographiclib Geodistpy Speedup vs Geopy 50 1,225 87 ms 58 ms 4.1 ms 21x 100 4,950 363 ms 236 ms 0.59 ms 613x 200 19,900 1.44 s 930 ms 1.17 ms 1,230x"},{"location":"explanation/#accuracy-geographiclib-as-reference-5000-random-pairs","title":"Accuracy (Geographiclib as reference, 5,000 random pairs)","text":"Method Mean Error (m) Max Error (m) Mean Rel. Error Geodistpy (Vincenty) 0.000009 0.000108 1.03e-12 Geopy (geodesic) 0.000000 0.000000 4.40e-17 Geodistpy (Great Circle) 19.23 462.88 2.34e-06 <p>Note: Geopy shows zero error because it wraps Geographiclib \u2014 it's the same algorithm. Geodistpy's Vincenty mean error of 9 micrometers is negligible. The Great Circle method uses an Andoyer-Lambert flattening correction that reduces error from ~13 km (pure sphere) to ~19 m \u2014 a 700x improvement.</p>"},{"location":"explanation/#great-circle-vs-geodesic-trade-off","title":"Great Circle vs Geodesic Trade-off","text":"Method Time (10,000 calls) Mean Error Use Case Great Circle + Andoyer-Lambert 3.0 ms ~19 m Fast with good accuracy Vincenty Geodesic 4.9 ms ~0.009 mm Maximum precision"},{"location":"explanation/#performance-summary","title":"Performance Summary","text":"<ul> <li>Single-pair: ~0.4 \u00b5s per call (171x faster than Geopy, 109x faster than Geographiclib)</li> <li>Matrix (N=200): 1.17 ms for 19,900 pairs (1,230x faster than Geopy)</li> <li>Vincenty accuracy: sub-millimeter (mean error = 9 \u00b5m)</li> <li>Great Circle accuracy: ~19 m mean error with Andoyer-Lambert flattening correction</li> <li>All edge cases handled: antipodal points, poles, date line crossings, short distances</li> </ul>"},{"location":"explanation/#key-implementation-details","title":"Key Implementation Details","text":""},{"location":"explanation/#vincentys-inverse-formula","title":"Vincenty's Inverse Formula","text":"<p>The core algorithm solves the inverse geodetic problem on the WGS84 ellipsoid using Vincenty's iterative method with 4th-order series expansions for the A and B Helmert coefficients. It is JIT-compiled with Numba using <code>fastmath=True</code> for additional floating-point optimizations.</p>"},{"location":"explanation/#andoyer-lambert-flattening-correction","title":"Andoyer-Lambert Flattening Correction","text":"<p>The Great Circle function applies a first-order correction for Earth's oblateness (WGS84 flattening f = 1/298.257223563). This dramatically improves accuracy compared to a pure spherical model while adding minimal computational cost.</p>"},{"location":"explanation/#numba-parallel-matrix-computation","title":"Numba Parallel Matrix Computation","text":"<p>Distance matrices use <code>@jit(parallel=True)</code> with <code>prange</code> for automatic multi-threaded execution, eliminating the overhead of Python-level callback functions that plague scipy-based approaches.</p>"},{"location":"explanation/#context-and-background","title":"Context and Background","text":"<p>The Python package <code>geodistpy</code> is a versatile library designed for geospatial calculations involving distances between geographical coordinates. It is built on the principles of geodesy and uses the WGS 84 coordinate system, which is commonly used in GPS and mapping applications.</p>"},{"location":"explanation/#why-it-was-created","title":"Why it was Created","text":"<p>The package was created to simplify and standardize geospatial distance calculations. Geographical distance calculations can be complex due to the curvature of the Earth's surface, and this library abstracts away those complexities, allowing users to focus on their specific geospatial tasks.</p>"},{"location":"explanation/#examples-and-approaches","title":"Examples and Approaches","text":"<p>Let's explore multiple examples and approaches to working with the <code>geodistpy</code> library:</p>"},{"location":"explanation/#example-1-calculating-distance-between-two-coordinates","title":"Example 1: Calculating Distance Between Two Coordinates","text":"<pre><code>from geodistpy import geodist\n\n# Define two coordinates in (latitude, longitude) format\ncoord1 = (52.5200, 13.4050)  # Berlin, Germany\ncoord2 = (48.8566, 2.3522)   # Paris, France\n\n# Calculate the distance between the two coordinates in kilometers\ndistance_km = geodist(coord1, coord2, metric='km')\nprint(f\"Distance between Berlin and Paris: {distance_km} kilometers\")\n</code></pre>"},{"location":"explanation/#example-2-calculating-distance-between-multiple-coordinates","title":"Example 2: Calculating Distance Between Multiple Coordinates","text":"<pre><code>from geodistpy import greatcircle_matrix\n\n# Define a list of coordinates\ncoords = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n\n# Calculate the distance matrix between all pairs of coordinates in miles\ndistance_matrix_miles = greatcircle_matrix(coords, metric='mile')\nprint(\"Distance matrix in miles:\")\nprint(distance_matrix_miles)\n</code></pre>"},{"location":"explanation/#example-3-working-with-different-metrics","title":"Example 3: Working with Different Metrics","text":"<p>The <code>geodistpy</code> library allows you to work with various distance metrics, such as meters, kilometers, miles, and nautical miles. You can easily switch between them by specifying the <code>metric</code> parameter.</p> <pre><code>from geodistpy import geodist\n\ncoord1 = (52.5200, 13.4050)  # Berlin, Germany\ncoord2 = (48.8566, 2.3522)   # Paris, France\n\n# Calculate the distance in meters\ndistance_meters = geodist(coord1, coord2, metric='meter')\n\n# Calculate the distance in nautical miles\ndistance_nautical_miles = geodist(coord1, coord2, metric='nmi')\n\nprint(f\"Distance in meters: {distance_meters}\")\nprint(f\"Distance in nautical miles: {distance_nautical_miles}\")\n</code></pre>"},{"location":"explanation/#conclusion","title":"Conclusion","text":"<p>For applications that demand rapid and precise geospatial distance computations, Geodistpy is the clear choice. It offers exceptional speed improvements over both Geopy and Geographiclib, making it ideal for tasks involving large datasets or real-time geospatial applications. Despite its speed, Geodistpy maintains accuracy on par with Geographiclib, ensuring that fast calculations do not compromise precision.</p> <p>By adopting Geodistpy, you can significantly enhance the efficiency and performance of your geospatial projects. It is a valuable tool for geospatial professionals and developers seeking both speed and accuracy in their distance computations.</p> <p>To get started with Geodistpy, visit the Geodistpy and explore the documentation for comprehensive usage instructions.</p>"},{"location":"getting-started/","title":"Getting-started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install the <code>geodistpy</code> package using <code>pip</code>:</p> <pre><code>pip install geodistpy\n</code></pre>"},{"location":"getting-started/#quick-start-guide","title":"Quick Start Guide","text":"<p>The quickest way to start using the <code>geodistpy</code> package is to calculate the distance between two geographical coordinates. Here's how you can do it:</p> <pre><code>from geodistpy import geodist\n\n# Define two coordinates in (latitude, longitude) format\ncoord1 = (52.5200, 13.4050)  # Berlin, Germany\ncoord2 = (48.8566, 2.3522)   # Paris, France\n\n# Calculate the distance between the two coordinates in kilometers\ndistance_km = geodist(coord1, coord2, metric='km')\nprint(f\"Distance between Berlin and Paris: {distance_km} kilometers\")\n</code></pre>"}]}