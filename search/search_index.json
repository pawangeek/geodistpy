{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Project Documentation","text":"<p>Welcome to the documentation for the <code>geodistpy</code> project. This documentation serves as a comprehensive guide to using and understanding the <code>geodistpy</code> Python package, which is designed for geospatial calculations involving distances between geographical coordinates.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation is organized to help you quickly find the information you need. Here are the main sections:</p> <ol> <li>Getting Started</li> <li>Explanation</li> <li>API Reference</li> </ol>"},{"location":"#introduction","title":"Introduction","text":"<p>The <code>geodistpy</code> package is a versatile library for geospatial calculations, offering various distance metrics and functionalities. It is built on the principles of geodesy and uses the WGS 84 coordinate system, making it suitable for a wide range of applications, from GPS tracking to geographical analysis.</p>"},{"location":"#license","title":"License","text":"<p>The geodistpy project is licensed under the MIT License.</p>"},{"location":"api-reference/","title":"API References","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>calculator</code> project code.</p> <p>Computation of geospatial distances (WGS84).</p>"},{"location":"api-reference/#geodistpy.distance--computation-of-geospatial-distances-wgs84","title":"Computation of Geospatial Distances (WGS84)","text":"<p>Coordinates are assumed to be in Latitude and Longitude (WGS 84). Accepting numpy arrays as input.</p> <p>The geospatial distance calculation is based on Vincenty's inverse method formula and accelerated with Numba (see <code>geokernels.geodesics.geodesic_vincenty</code> and references).</p> <p>In a few cases (&lt;0.01%) Vincenty's inverse method can fail to converge, and a fallback option using the slower geographiclib solution is implemented.</p>"},{"location":"api-reference/#geodistpy.distance--functions-included","title":"Functions Included:","text":"<ul> <li><code>geodist</code>: returns a list of distances between points of two lists: <code>dist[i] = distance(XA[i], XB[i])</code></li> <li><code>geodist_matrix</code>: returns a distance matrix between all possible combinations of pairwise distances (either between all points in one list or points between two lists). <code>dist[i,j] = distance(XA[i], XB[j])</code> or <code>distance(X[i], X[j])</code></li> </ul> <p>This implementation provides a fast computation of geo-spatial distances in comparison to alternative methods for computing geodesic distance (tested: geopy and GeographicLib, see <code>geokernels.test_geodesics</code> for test functions).</p>"},{"location":"api-reference/#geodistpy.distance--references","title":"References:","text":"<ul> <li>Vincenty's Formulae</li> <li>GeographicLib</li> <li>Karney, Charles F. F. (January 2013). \"Algorithms for geodesics\". Journal of Geodesy. 87 (1): 43\u201355. arXiv:1109.4448. Bibcode:2013JGeod..87...43K. doi:10.1007/s00190-012-0578-z. Addenda.</li> </ul>"},{"location":"api-reference/#geodistpy.distance.geodist","title":"<code>geodist(coords1, coords2, metric='meter')</code>","text":"<p>Return distances between two coordinates or two lists of coordinates.</p> <p>Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.</p> <p>For distances between all pair combinations, see geo_pdist and geo_cdist.</p> <p>Parameters:</p> Name Type Description Default <code>coords1</code> <code>array - like</code> <p>The first set of coordinates in the format (latitude, longitude) or an array with shape (n_points1, 2) for multiple points.</p> required <code>coords2</code> <code>array - like</code> <p>The second set of coordinates in the format (latitude, longitude) or an array with shape (n_points2, 2) for multiple points. The shape of coords1 should match the shape of coords2.</p> required <code>metric</code> <code>str</code> <p>The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'. Default is 'meter'.</p> <code>'meter'</code> <p>Returns:</p> Type Description <p>float or ndarray: The distance(s) between points, with a length of n_points.</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If the input coordinates do not have the expected shape.</li> <li>If latitude values are not in the range [-90, 90].</li> <li>If longitude values are not in the range [-180, 180].</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geodist((52.5200, 13.4050), (48.8566, 2.3522), metric='km')\n878.389841013836\n</code></pre> <pre><code>&gt;&gt;&gt; coords1 = [(37.7749, -122.4194), (34.0522, -118.2437)]\n&gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n&gt;&gt;&gt; geodist(coords1, coords2, metric='mile')\narray([2449.92107243, 1745.82567572])\n</code></pre> <pre><code>&gt;&gt;&gt; geodist((37.7749, -122.4194), (37.7749, -122.4194))\n0.0\n</code></pre> Source code in <code>geodistpy/distance.py</code> <pre><code>def geodist(coords1, coords2, metric=\"meter\"):\n    \"\"\"\n    Return distances between two coordinates or two lists of coordinates.\n\n    Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.\n\n    For distances between all pair combinations, see geo_pdist and geo_cdist.\n\n    Parameters:\n        coords1 (array-like): The first set of coordinates in the format (latitude, longitude) or an array with shape (n_points1, 2) for multiple points.\n        coords2 (array-like): The second set of coordinates in the format (latitude, longitude) or an array with shape (n_points2, 2) for multiple points.\n            The shape of coords1 should match the shape of coords2.\n        metric (str, optional): The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'.\n            Default is 'meter'.\n\n    Returns:\n        float or ndarray: The distance(s) between points, with a length of n_points.\n\n    Raises:\n        ValueError:\n            - If the input coordinates do not have the expected shape.\n            - If latitude values are not in the range [-90, 90].\n            - If longitude values are not in the range [-180, 180].\n\n    Examples:\n        &gt;&gt;&gt; geodist((52.5200, 13.4050), (48.8566, 2.3522), metric='km')\n        878.389841013836\n\n        &gt;&gt;&gt; coords1 = [(37.7749, -122.4194), (34.0522, -118.2437)]\n        &gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n        &gt;&gt;&gt; geodist(coords1, coords2, metric='mile')\n        array([2449.92107243, 1745.82567572])\n\n        &gt;&gt;&gt; geodist((37.7749, -122.4194), (37.7749, -122.4194))\n        0.0\n    \"\"\"\n    coords1 = np.asarray(coords1)\n    coords2 = np.asarray(coords2)\n    assert coords1.shape == coords2.shape\n\n    conv_fac = _get_conv_factor(metric)\n\n    if np.size(coords1) == 2:\n        if coords1.shape[0] != 2 or coords2.shape[0] != 2:\n            raise ValueError(\n                \"coords1 and coords2 must have two dimensions: Latitude, Longitude\"\n            )\n        if (abs(coords1[0]) &gt; 90).any() or (abs(coords2[0]) &gt; 90).any():\n            raise ValueError(\"Latitude values must be in the range [-90, 90]\")\n        if (abs(coords1[1]) &gt; 180).any() or (abs(coords2[1]) &gt; 180).any():\n            raise ValueError(\"Longitude values must be in the range [-180, 180]\")\n        return geodesic_vincenty(coords1, coords2) * conv_fac\n\n    if coords1.shape[1] != 2:\n        raise ValueError(\n            \"coords1 and coords2 must have two dimensions: Latitude, Longitude\"\n        )\n    if (abs(coords1[:, 0]) &gt; 90).any() or (abs(coords2[:, 0]) &gt; 90).any():\n        raise ValueError(\"Latitude values must be in the range [-90, 90]\")\n    if (abs(coords1[:, 1]) &gt; 180).any() or (abs(coords2[:, 1]) &gt; 180).any():\n        raise ValueError(\"Longitude values must be in the range [-180, 180]\")\n    n_points = len(coords1)\n    dist = np.asarray(\n        [geodesic_vincenty(coords1[i], coords2[i]) for i in range(n_points)]\n    )\n    return dist * conv_fac\n</code></pre>"},{"location":"api-reference/#geodistpy.distance.geodist_matrix","title":"<code>geodist_matrix(coords1, coords2=None, metric='meter')</code>","text":"<p>Compute distance between each pair of possible combinations.</p> <p>If coords2 is None, compute distance between all possible pair combinations in coords1. dist[i, j] = distance(XA[i], XB[j])</p> <p>If coords2 is given, compute distance between each possible pair of the two collections of inputs: dist[i, j] = distance(X[i], X[j])</p> <p>Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.</p> <p>Parameters:</p> Name Type Description Default <code>coords1</code> <code>list of tuples</code> <p>List of coordinates in the format [(lat, long)] or an array with shape (n_points1, 2).</p> required <code>coords2</code> <code>list of tuples</code> <p>List of coordinates in the format [(lat, long)] or an array with shape (n_points2, 2). If coords2 is not None, coords1.shape must match coords2.shape. Default is None.</p> <code>None</code> <code>metric</code> <code>str</code> <p>The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'. Default is 'meter'.</p> <code>'meter'</code> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>A distance matrix is returned. - If only coords1 is given, for each i and j, the metric dist(u=XA[i], v=XA[j]) is computed. - If coords2 is not None, for each i and j, the metric dist(u=XA[i], v=XB[j]) is computed and stored in the ij-th entry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If the input coordinates do not have the expected shape.</li> <li>If latitude values are not in the range [-90, 90].</li> <li>If longitude values are not in the range [-180, 180].</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; coords1 = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n&gt;&gt;&gt; geodist_matrix(coords1, metric='km')\narray([[   0.        ,  878.38984101, 8786.58652276],\n       [ 878.38984101,    0.        , 9525.03650888],\n       [8786.58652276, 9525.03650888,    0.        ]])\n</code></pre> <pre><code>&gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n&gt;&gt;&gt; geodist_matrix(coords1, coords2, metric='mile')\narray([[ 3060.81391478, 2437.78157493],\n       [ 4290.62813902, 1745.82567572],\n       [ 2449.92107243, 1746.57308007]])\n</code></pre> Source code in <code>geodistpy/distance.py</code> <pre><code>def geodist_matrix(coords1, coords2=None, metric=\"meter\"):\n    \"\"\"\n    Compute distance between each pair of possible combinations.\n\n    If coords2 is None, compute distance between all possible pair combinations in coords1.\n    dist[i, j] = distance(XA[i], XB[j])\n\n    If coords2 is given, compute distance between each possible pair of the two collections\n    of inputs: dist[i, j] = distance(X[i], X[j])\n\n    Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.\n\n    Parameters:\n        coords1 (list of tuples): List of coordinates in the format [(lat, long)] or an array with shape (n_points1, 2).\n        coords2 (list of tuples, optional): List of coordinates in the format [(lat, long)] or an array with shape (n_points2, 2).\n            If coords2 is not None, coords1.shape must match coords2.shape.\n            Default is None.\n        metric (str, optional): The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'.\n            Default is 'meter'.\n\n    Returns:\n        ndarray: A distance matrix is returned.\n            - If only coords1 is given, for each i and j, the metric dist(u=XA[i], v=XA[j]) is computed.\n            - If coords2 is not None, for each i and j, the metric dist(u=XA[i], v=XB[j]) is computed and stored in the ij-th entry.\n\n    Raises:\n        ValueError:\n            - If the input coordinates do not have the expected shape.\n            - If latitude values are not in the range [-90, 90].\n            - If longitude values are not in the range [-180, 180].\n\n    Examples:\n        &gt;&gt;&gt; coords1 = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n        &gt;&gt;&gt; geodist_matrix(coords1, metric='km')\n        array([[   0.        ,  878.38984101, 8786.58652276],\n               [ 878.38984101,    0.        , 9525.03650888],\n               [8786.58652276, 9525.03650888,    0.        ]])\n\n        &gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n        &gt;&gt;&gt; geodist_matrix(coords1, coords2, metric='mile')\n        array([[ 3060.81391478, 2437.78157493],\n               [ 4290.62813902, 1745.82567572],\n               [ 2449.92107243, 1746.57308007]])\n    \"\"\"\n    conv_fac = _get_conv_factor(metric)\n\n    coords1 = np.asarray(coords1)\n    if coords1.shape[1] != 2:\n        raise ValueError(\n            \"coords1 and coords2 must have two dimensions: Latitude, Longitude\"\n        )\n    if (abs(coords1[:, 0]) &gt; 90).any() or (abs(coords1[:, 1]) &gt; 180).any():\n        raise ValueError(\n            \"Latitude values must be in the range [-90, 90] and Longitude values must be in the range [-180, 180].\"\n        )\n\n    if coords2 is None:\n        dist = pdist(coords1, metric=lambda u, v: geodesic_vincenty(u, v))\n        dist = squareform(dist)\n    else:\n        coords2 = np.asarray(coords2)\n\n        # If two lists of coordinates are given\n        assert coords1.shape == coords2.shape\n        if (abs(coords2[:, 0]) &gt; 90).any() or (abs(coords2[:, 1]) &gt; 180).any():\n            raise ValueError(\n                \"Latitude values must be in the range [-90, 90] and Longitude values must be in the range [-180, 180].\"\n            )\n        dist = cdist(coords1, coords2, metric=lambda u, v: geodesic_vincenty(u, v))\n    return dist * conv_fac\n</code></pre>"},{"location":"api-reference/#geodistpy.distance.greatcircle","title":"<code>greatcircle(coords1, coords2, metric='meter')</code>","text":"<p>Calculate the distance between two sets of coordinates using the Great Circle approximation.</p> <p>Parameters:</p> Name Type Description Default <code>coords1</code> <code>array - like</code> <p>The first set of coordinates in the format (latitude, longitude) or an array with shape (n_points1, 2) for multiple points.</p> required <code>coords2</code> <code>array - like</code> <p>The second set of coordinates in the format (latitude, longitude) or an array with shape (n_points2, 2) for multiple points. The shape of coords1 should match the shape of coords2.</p> required <code>metric</code> <code>str</code> <p>The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'. Default is 'meter'.</p> <code>'meter'</code> <p>Returns:</p> Type Description <p>float or ndarray: The distance(s) between the points. If multiple points are provided, an ndarray is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If the input coordinates do not have the expected shape.</li> <li>If latitude values are not in the range [-90, 90].</li> <li>If longitude values are not in the range [-180, 180].</li> </ul> Notes <p>The Great Circle formula assumes a spherical Earth and may not be completely accurate for very long distances or in regions with significant variation in the Earth's curvature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; greatcircle((52.5200, 13.4050), (48.8566, 2.3522), metric='km')\n878.389841013836\n</code></pre> <pre><code>&gt;&gt;&gt; coords1 = [(37.7749, -122.4194), (34.0522, -118.2437)]\n&gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n&gt;&gt;&gt; greatcircle(coords1, coords2, metric='mile')\narray([2449.92107243, 1745.82567572])\n</code></pre> <pre><code>&gt;&gt;&gt; greatcircle((37.7749, -122.4194), (37.7749, -122.4194))\n0.0\n</code></pre> Source code in <code>geodistpy/distance.py</code> <pre><code>def greatcircle(coords1, coords2, metric=\"meter\"):\n    \"\"\"Calculate the distance between two sets of coordinates using the Great Circle approximation.\n\n    Args:\n        coords1 (array-like): The first set of coordinates in the format (latitude, longitude) or an array with shape (n_points1, 2) for multiple points.\n        coords2 (array-like): The second set of coordinates in the format (latitude, longitude) or an array with shape (n_points2, 2) for multiple points.\n            The shape of coords1 should match the shape of coords2.\n        metric (str, optional): The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'.\n            Default is 'meter'.\n\n    Returns:\n        float or ndarray: The distance(s) between the points. If multiple points are provided, an ndarray is returned.\n\n    Raises:\n        ValueError:\n            - If the input coordinates do not have the expected shape.\n            - If latitude values are not in the range [-90, 90].\n            - If longitude values are not in the range [-180, 180].\n\n    Notes:\n        The Great Circle formula assumes a spherical Earth and may not be completely accurate\n        for very long distances or in regions with significant variation in the Earth's curvature.\n\n    Examples:\n        &gt;&gt;&gt; greatcircle((52.5200, 13.4050), (48.8566, 2.3522), metric='km')\n        878.389841013836\n\n        &gt;&gt;&gt; coords1 = [(37.7749, -122.4194), (34.0522, -118.2437)]\n        &gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n        &gt;&gt;&gt; greatcircle(coords1, coords2, metric='mile')\n        array([2449.92107243, 1745.82567572])\n\n        &gt;&gt;&gt; greatcircle((37.7749, -122.4194), (37.7749, -122.4194))\n        0.0\n    \"\"\"\n    coords1 = np.asarray(coords1)\n    coords2 = np.asarray(coords2)\n    assert coords1.shape == coords2.shape\n\n    conv_fac = _get_conv_factor(metric)\n\n    if np.size(coords1) == 2:\n        return great_circle_array(coords1, coords2) * conv_fac\n    if coords1.shape[1] != 2:\n        raise ValueError(\n            \"coords1 and coords2 must have two dimensions: Latitude, Longitude\"\n        )\n    if (abs(coords1[:, 0]) &gt; 90).any() or (abs(coords2[:, 0]) &gt; 90).any():\n        raise ValueError(\"Latitude values must be in the range [-90, 90]\")\n    if (abs(coords1[:, 1]) &gt; 180).any() or (abs(coords2[:, 1]) &gt; 180).any():\n        raise ValueError(\"Longitude values must be in the range [-180, 180]\")\n\n    dist = great_circle_array(coords1, coords2)\n    return dist * conv_fac\n</code></pre>"},{"location":"api-reference/#geodistpy.distance.greatcircle_matrix","title":"<code>greatcircle_matrix(coords1, coords2=None, metric='meter')</code>","text":"<p>Compute distance between each pair of possible combinations using spherical asymmetry (Great Circle approximation).</p> <p>If coords2 is None, compute distance between all possible pair combinations in coords1. dist[i, j] = distance(XA[i], XB[j])</p> <p>If coords2 is given, compute distance between each possible pair of the two collections of inputs: dist[i, j] = distance(X[i], X[j])</p> <p>Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.</p> <p>Parameters:</p> Name Type Description Default <code>coords1</code> <code>list of tuples</code> <p>List of coordinates in the format [(lat, long)] or an array with shape (n_points1, 2).</p> required <code>coords2</code> <code>list of tuples</code> <p>List of coordinates in the format [(lat, long)] or an array with shape (n_points2, 2). If coords2 is not None, coords1.shape must match coords2.shape. Default is None.</p> <code>None</code> <code>metric</code> <code>str</code> <p>The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'. Default is 'meter'.</p> <code>'meter'</code> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>A distance matrix is returned. - If only coords1 is given, for each i and j, the metric dist(u=XA[i], v=XA[j]) is computed. - If coords2 is not None, for each i and j, the metric dist(u=XA[i], v=XB[j]) is computed and stored in the ij-th entry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <ul> <li>If the input coordinates do not have the expected shape.</li> <li>If latitude values are not in the range [-90, 90].</li> <li>If longitude values are not in the range [-180, 180].</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; coords1 = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n&gt;&gt;&gt; greatcircle_matrix(coords1, metric='km')\narray([[   0.        ,  878.38984101, 8786.58652276],\n       [ 878.38984101,    0.        , 9525.03650888],\n       [8786.58652276, 9525.03650888,    0.        ]])\n</code></pre> <pre><code>&gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n&gt;&gt;&gt; greatcircle_matrix(coords1, coords2, metric='mile')\narray([[ 3060.81391478, 2437.78157493],\n       [ 4290.62813902, 1745.82567572],\n       [ 2449.92107243, 1746.57308007]])\n</code></pre> Source code in <code>geodistpy/distance.py</code> <pre><code>def greatcircle_matrix(coords1, coords2=None, metric=\"meter\"):\n    \"\"\"\n    Compute distance between each pair of possible combinations\n    using spherical asymmetry (Great Circle approximation).\n\n    If coords2 is None, compute distance between all possible pair combinations in coords1.\n    dist[i, j] = distance(XA[i], XB[j])\n\n    If coords2 is given, compute distance between each possible pair of the two collections\n    of inputs: dist[i, j] = distance(X[i], X[j])\n\n    Coordinates are assumed to be in Latitude, Longitude (WGS 84) format.\n\n    Parameters:\n        coords1 (list of tuples): List of coordinates in the format [(lat, long)] or an array with shape (n_points1, 2).\n        coords2 (list of tuples, optional): List of coordinates in the format [(lat, long)] or an array with shape (n_points2, 2).\n            If coords2 is not None, coords1.shape must match coords2.shape.\n            Default is None.\n        metric (str, optional): The unit of measurement for the calculated distances. Possible values are 'meter', 'km', 'mile', or 'nmi'.\n            Default is 'meter'.\n\n    Returns:\n        ndarray: A distance matrix is returned.\n            - If only coords1 is given, for each i and j, the metric dist(u=XA[i], v=XA[j]) is computed.\n            - If coords2 is not None, for each i and j, the metric dist(u=XA[i], v=XB[j]) is computed and stored in the ij-th entry.\n\n    Raises:\n        ValueError:\n            - If the input coordinates do not have the expected shape.\n            - If latitude values are not in the range [-90, 90].\n            - If longitude values are not in the range [-180, 180].\n\n    Examples:\n        &gt;&gt;&gt; coords1 = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n        &gt;&gt;&gt; greatcircle_matrix(coords1, metric='km')\n        array([[   0.        ,  878.38984101, 8786.58652276],\n               [ 878.38984101,    0.        , 9525.03650888],\n               [8786.58652276, 9525.03650888,    0.        ]])\n\n        &gt;&gt;&gt; coords2 = [(40.7128, -74.0060), (41.8781, -87.6298)]\n        &gt;&gt;&gt; greatcircle_matrix(coords1, coords2, metric='mile')\n        array([[ 3060.81391478, 2437.78157493],\n               [ 4290.62813902, 1745.82567572],\n               [ 2449.92107243, 1746.57308007]])\n    \"\"\"\n    conv_fac = _get_conv_factor(metric)\n\n    coords1 = np.asarray(coords1)\n    if coords1.shape[1] != 2:\n        raise ValueError(\n            \"coords1 and coords2 must have two dimensions: Latitude, Longitude\"\n        )\n    if (abs(coords1[:, 0]) &gt; 90).any() or (abs(coords1[:, 1]) &gt; 180).any():\n        raise ValueError(\n            \"Latitude values must be in the range [-90, 90] and Longitude values must be in the range [-180, 180].\"\n        )\n\n    if coords2 is None:\n        # If only one list of coordinates is given:\n        dist = pdist(coords1, metric=lambda u, v: great_circle(u, v))\n        dist = squareform(dist)\n    else:\n        coords2 = np.asarray(coords2)\n        assert coords1.shape == coords2.shape\n\n        if (abs(coords2[:, 0]) &gt; 90).any() or (abs(coords2[:, 1]) &gt; 180).any():\n            raise ValueError(\n                \"Latitude values must be in the range [-90, 90] and Longitude values must be in the range [-180, 180].\"\n            )\n        dist = cdist(coords1, coords2, metric=lambda u, v: great_circle(u, v))\n    return dist * conv_fac\n</code></pre>"},{"location":"explanation/","title":"Explanation","text":"<p>Geodistpy is a powerful Python library designed for lightning-fast geospatial distance computations. In this README, we'll compare Geodistpy with two other popular libraries, Geopy and Geographiclib, to highlight the significant performance advantages of Geodistpy.</p>"},{"location":"explanation/#speed-comparison","title":"Speed Comparison","text":"<pre><code># Import libraries\nfrom geopy.distance import geodesic as geodesic_geopy\nfrom geographiclib.geodesic import Geodesic as geodesic_gglib\nfrom geokernels.geodesics import geodesic_vincenty\n\n# Define two coordinates\ncoord1 = (52.5200, 13.4050)  # Berlin\ncoord2 = (48.8566, 2.3522)   # Paris\n\n# Calculate distance with Geopy (based on Geographiclib)\ndistance_geopy = geodesic_geopy(coord1, coord2).meters\n\n# Calculate distance with Geographiclib\ndistance_gglib = geodesic_gglib.WGS84.Inverse(coord1[0], coord1[1], coord2[0], coord2[1])['s12']\n\n# Calculate distance with Geokernels\ndistance_geokernels = geodesic_vincenty(coord1, coord2)\n\n# Print the results\nprint(f\"Distance between Berlin and Paris:\")\nprint(f\"Geopy: {distance_geopy} meters\")\nprint(f\"Geographiclib: {distance_gglib} meters\")\nprint(f\"Geokernels: {distance_geokernels} meters\")\n\n</code></pre> <p>We conducted a speed comparison between Geodistpy, Geopy, and Geographiclib using 1000 random samples of coordinates (latitude and longitude). The goal was to calculate all pairwise distances between these coordinates.</p>"},{"location":"explanation/#geopy-geodesic-from-geographiclib","title":"Geopy (Geodesic from Geographiclib)","text":"<ul> <li>Computation Time: Approximately 53.356 seconds</li> <li>Accuracy: Comparable to Geographiclib</li> <li>Geopy is widely known but relatively slow for distance calculations.</li> </ul>"},{"location":"explanation/#geographiclib","title":"Geographiclib","text":"<ul> <li>Computation Time: Approximately 36.824 seconds</li> <li>Accuracy: High</li> <li>Geographiclib is established but still lags in terms of speed.</li> </ul>"},{"location":"explanation/#geodistpy-accelerated-vincentys-inverse","title":"Geodistpy (Accelerated Vincenty's Inverse)","text":"<ul> <li>Computation Time: Approximately 0.701 seconds (initial run, including Numba compilation) and 0.393 seconds (subsequent runs)</li> <li>Accuracy: High, comparable to Geographiclib</li> <li>Geodistpy uses an optimized Vincenty's Inverse method for blazingly fast distance calculations.</li> </ul>"},{"location":"explanation/#performance-comparison","title":"Performance Comparison","text":"<ul> <li>Geodistpy is 78 to 142 times faster than Geopy.</li> <li>Geodistpy is 53 to 94 times faster than Geographiclib.</li> </ul>"},{"location":"explanation/#conclusion","title":"Conclusion","text":"<p>For applications that demand rapid and precise geospatial distance computations, Geodistpy is the clear choice. It offers exceptional speed improvements over both Geopy and Geographiclib, making it ideal for tasks involving large datasets or real-time geospatial applications. Despite its speed, Geodistpy maintains accuracy on par with Geographiclib, ensuring that fast calculations do not compromise precision.</p> <p>By adopting Geodistpy, you can significantly enhance the efficiency and performance of your geospatial projects. It is a valuable tool for geospatial professionals and developers seeking both speed and accuracy in their distance computations.</p> <p>To get started with Geodistpy, visit the Geodistpy and explore the documentation for comprehensive usage instructions.</p>"},{"location":"explanation/#context-and-background","title":"Context and Background","text":"<p>The Python package <code>geodistpy</code> is a versatile library designed for geospatial calculations involving distances between geographical coordinates. It is built on the principles of geodesy and uses the WGS 84 coordinate system, which is commonly used in GPS and mapping applications.</p>"},{"location":"explanation/#why-it-was-created","title":"Why it was Created","text":"<p>The package was created to simplify and standardize geospatial distance calculations. Geographical distance calculations can be complex due to the curvature of the Earth's surface, and this library abstracts away those complexities, allowing users to focus on their specific geospatial tasks.</p>"},{"location":"explanation/#examples-and-approaches","title":"Examples and Approaches","text":"<p>Let's explore multiple examples and approaches to working with the <code>geodistpy</code> library:</p>"},{"location":"explanation/#example-1-calculating-distance-between-two-coordinates","title":"Example 1: Calculating Distance Between Two Coordinates","text":"<pre><code>from geodistpy import geodist\n\n# Define two coordinates in (latitude, longitude) format\ncoord1 = (52.5200, 13.4050)  # Berlin, Germany\ncoord2 = (48.8566, 2.3522)   # Paris, France\n\n# Calculate the distance between the two coordinates in kilometers\ndistance_km = geodist(coord1, coord2, metric='km')\nprint(f\"Distance between Berlin and Paris: {distance_km} kilometers\")\n</code></pre>"},{"location":"explanation/#example-2-calculating-distance-between-multiple-coordinates","title":"Example 2: Calculating Distance Between Multiple Coordinates","text":"<pre><code>from geodistpy import greatcircle_matrix\n\n# Define a list of coordinates\ncoords = [(52.5200, 13.4050), (48.8566, 2.3522), (37.7749, -122.4194)]\n\n# Calculate the distance matrix between all pairs of coordinates in miles\ndistance_matrix_miles = greatcircle_matrix(coords, metric='mile')\nprint(\"Distance matrix in miles:\")\nprint(distance_matrix_miles)\n</code></pre>"},{"location":"explanation/#example-3-working-with-different-metrics","title":"Example 3: Working with Different Metrics","text":"<p>The <code>geodistpy</code> library allows you to work with various distance metrics, such as meters, kilometers, miles, and nautical miles. You can easily switch between them by specifying the <code>metric</code> parameter.</p> <p>```python from geodistpy import geodist</p> <p>coord1 = (52.5200, 13.4050)  # Berlin, Germany coord2 = (48.8566, 2.3522)   # Paris, France</p>"},{"location":"explanation/#calculate-the-distance-in-meters","title":"Calculate the distance in meters","text":"<p>distance_meters = geodist(coord1, coord2, metric='meter')</p>"},{"location":"explanation/#calculate-the-distance-in-nautical-miles","title":"Calculate the distance in nautical miles","text":"<p>distance_nautical_miles = geodist(coord1, coord2, metric='nmi')</p> <p>print(f\"Distance in meters: {distance_meters}\") print(f\"Distance in nautical miles: {distance_nautical_miles}\")</p>"},{"location":"getting-started/","title":"Getting-started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install the <code>geodistpy</code> package using <code>pip</code>:</p> <pre><code>pip install geodistpy\n</code></pre>"},{"location":"getting-started/#quick-start-guide","title":"Quick Start Guide","text":"<p>The quickest way to start using the <code>geodistpy</code> package is to calculate the distance between two geographical coordinates. Here's how you can do it:</p> <pre><code>from geodistpy import geodist\n\n# Define two coordinates in (latitude, longitude) format\ncoord1 = (52.5200, 13.4050)  # Berlin, Germany\ncoord2 = (48.8566, 2.3522)   # Paris, France\n\n# Calculate the distance between the two coordinates in kilometers\ndistance_km = geodist(coord1, coord2, metric='km')\nprint(f\"Distance between Berlin and Paris: {distance_km} kilometers\")\n</code></pre>"}]}